<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>array: About</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">array
   </div>
   <div id="projectbrief">C++ library for multi-dimensional arrays</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">About </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This library provides a multidimensional array class for C++, with the following design goals:</p><ul>
<li>Enable specification of array parameters as <a href="#compile-time-constant-shapes">compile-time constants</a> per parameter, enabling more efficient code generation, while retaining run-time flexibility where needed.</li>
<li>Provide an API following the conventions of the C++ STL where possible.</li>
<li>Minimal dependencies and requirements (the library is currently a single header file, and depends only on the C++ STL).</li>
</ul>
<p>The library uses some ideas established in other existing projects, such as <a href="https://numpy.org/doc/1.17/reference/arrays.ndarray.html">numpy</a>, <a href="https://halide-lang.org/docs/class_halide_1_1_runtime_1_1_buffer.html">Halide</a>, and <a href="http://eigen.tuxfamily.org">Eigen</a>. Array shapes are specified as a list of N dimensions, where each dimension has parameters such as an extent and a stride. Array references and objects use shape objects to map N-dimensional indices to a flat index. N-dimensional indices are mapped to flat offsets with the following formula: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;flat_offset = (x0 - min0)*stride0 + (x1 - min1)*stride1 + ... + (xN - minN)*strideN</div></div><!-- fragment --><p> where:</p><ul>
<li><code>xN</code> are the indices in each dimension.</li>
<li><code>minN</code> are the mins in each dimension. The min is the value of the first in-range index in this dimension (the max is <code>minN + extentN - 1</code>).</li>
<li><code>strideN</code> are the distances in the flat offsets between elements in each dimension.</li>
</ul>
<p>Arrays efficiently support advanced manipulations like <a href="#slicing-cropping-and-splitting">cropping, slicing, and splitting</a> arrays and loops, all while preserving compile-time constant parameters when possible. Although it is a heavily templated library, incorrect usage generates informative and helpful error messages. Typically, an issue will result in only one error message, located at the site of the problem in user code. This is something <a href="https://github.com/dsharlet/array/blob/master/test/errors.cpp#L18-L19">we test for</a>.</p>
<p>Many other libraries offering multi-dimensional arrays or tensors allow compile-time constant shapes. <em>However</em>, most if not all of them only allow either all of the shape parameters to be compile-time constant, or none of them. This is really limiting; often only a few key parameters of a shape need to be compile-time constant for performance, while other dimensions need flexibility to accommodate runtime-valued shape parameters. Some examples of this are:</p><ul>
<li>'<a href="https://en.wikipedia.org/wiki/Packed_pixel">Chunky</a>' image formats with a small fixed number of channels.</li>
<li>Matrices where one dimension represent variables intrinsic to the problem, while the other dimension represents a number of samples of data.</li>
<li>Algorithms optimized by splitting or tiling intermediate stages will have intermediate buffers that have a constant extent in the dimensions that are split or tiled.</li>
</ul>
<p>Some other features of the library are:</p><ul>
<li><a href="#cuda-support">CUDA support</a> for use in <code>__device__</code> functions.</li>
<li><a href="#einstein-reductions">Einstein reduction</a> helpers, enabling many kinds of reductions and other array operations to be expressed safely.</li>
</ul>
<p>For more detailed documentation, see the generated <a href="https://dsharlet.github.io/array/files.html">documentation</a>.</p>
<h2>Usage</h2>
<h3>Shapes</h3>
<p>The basic types provided by the library are:</p><ul>
<li><code>dim&lt;Min, Extent, Stride&gt;</code>, a description of a single dimension. The template parameters specify a compile-time constant min, extent, or stride, or are <code>dynamic</code> (meaning unknown) and are specified at runtime.</li>
<li><code>shape&lt;Dim0, Dim1, ...&gt;</code>, a description of multiple dimensions. <code>Dim0</code> is referred to as the innermost dimension.</li>
<li><code>array&lt;T, Shape, Allocator&gt;</code>, a container following the conventions of <code>std::vector</code> where possible. This container manages the allocation of a buffer associated with a <code>Shape</code>.</li>
<li><code>array_ref&lt;T, Shape&gt;</code>, a wrapper for addressing existing memory with a shape <code>Shape</code>.</li>
</ul>
<p>To define an array, define a shape type, and use it to define an array object: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  using my_3d_shape_type = shape&lt;dim&lt;&gt;, dim&lt;&gt;, dim&lt;&gt;&gt;;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  constexpr int width = 16;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  constexpr int height = 10;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  constexpr int depth = 3;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  my_3d_shape_type my_3d_shape(width, height, depth);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  array&lt;int, my_3d_shape_type&gt; my_array(my_3d_shape);</div></div><!-- fragment --><p>General shapes and arrays like this have the following built-in aliases:</p><ul>
<li><code>shape_of_rank&lt;N&gt;</code>, an N-dimensional shape.</li>
<li><code>array_ref_of_rank&lt;T, N&gt;</code> and <code>array_of_rank&lt;T, N, Allocator&gt;</code>, N-dimensional arrays with a shape of <code>shape_of_rank&lt;N&gt;</code>.</li>
</ul>
<h3>Access and iteration</h3>
<p>Accessing <code>array</code> or <code>array_ref</code> is done via <code>operator(...)</code> and <code>operator[index_type]</code>. There are both variadic and <code>index_type</code> overloads of <code>operator()</code>. <code>index_type</code> is a specialization of <code>std::tuple</code> defined by <code>shape</code> (and <code>array</code> and <code>array_ref</code>), e.g. <code>my_3d_shape_type::index_type</code>. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  for (int z = 0; z &lt; depth; z++) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    for (int y = 0; y &lt; height; y++) {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;      for (int x = 0; x &lt; width; x++) {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        // Variadic version:</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        my_array(x, y, z) = 5;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        // Or the index_type version:</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        my_array[{x, y, z}] = 5;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;      }</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    }</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  }</div></div><!-- fragment --><p><code>array::for_each_value</code> and <code>array_ref::for_each_value</code> calls a function with a reference to each value in the array. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  my_array.for_each_value([](int&amp; value) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    value = 5;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  });</div></div><!-- fragment --><p><code>for_all_indices</code> is a free function taking a shape object and a function to call with every index in the shape. <code>for_each_index</code> is similar, calling a free function with the index as an instance of the index type <code>my_3d_shape_type::index_type</code>. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  for_all_indices(my_3d_shape, [&amp;](int x, int y, int z) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    my_array(x, y, z) = 5;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  });</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  for_each_index(my_3d_shape, [&amp;](my_3d_shape_type::index_type i) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    my_array[i] = 5;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  });</div></div><!-- fragment --><p>The order in which each of <code>for_each_value</code>, <code>for_each_index</code>, and <code>for_all_indices</code> execute their traversal over the shape is defined by <code>shape_traits&lt;Shape&gt;</code>. The default implementation of <code>shape_traits&lt;Shape&gt;::for_each_index</code> iterates over the innermost dimension as the innermost loop, and proceeds in order to the outermost dimension. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  my_3d_shape_type my_shape(2, 2, 2);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  for_all_indices(my_shape, [](int x, int y, int z) {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;, &quot; &lt;&lt; z &lt;&lt; std::endl;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  });</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  // Output:</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  // 0, 0, 0</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  // 1, 0, 0</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  // 0, 1, 0</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  // 1, 1, 0</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  // 0, 0, 1</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  // 1, 0, 1</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  // 0, 1, 1</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  // 1, 1, 1</div></div><!-- fragment --><p>The default implementation of <code>shape_traits&lt;Shape&gt;::for_each_value</code> iterates over a dynamically optimized shape. The order will vary depending on the properties of the shape.</p>
<p>There are overloads of <code>for_all_indices</code> and <code>for_each_index</code> accepting a permutation to indicate the loop order. In this example, the permutation <code>&lt;2, 0, 1&gt;</code> iterates over the <code>z</code> dimension as the innermost loop, then <code>x</code>, then <code>y</code>. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  for_all_indices&lt;2, 0, 1&gt;(my_shape, [](int x, int y, int z) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;, &quot; &lt;&lt; z &lt;&lt; std::endl;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  });</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  // Output:</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  // 0, 0, 0</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  // 0, 0, 1</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  // 1, 0, 0</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  // 1, 0, 1</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  // 0, 1, 0</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  // 0, 1, 1</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  // 1, 1, 0</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  // 1, 1, 1</div></div><!-- fragment --><h3>Compile-time constant shapes</h3>
<p>In the previous examples, no array parameters are compile time constants, so all of these accesses and loops expand to a <code>flat_offset</code> expression where the mins, extents, and strides are runtime variables. This can prevent the compiler from generating efficient code. For example, the compiler may be able to auto-vectorize these loops, but if the stride of the dimension accessed by the vectorized loop is a runtime variable, the compiler will have to generate gathers and scatters instead of vector load and store instructions, even if the stride is one at runtime.</p>
<p>To avoid this, we need to make array parameters compile time constants. However, while making array parameters compile time constants helps the compiler generate efficient code, it also makes the program less flexible.</p>
<p>This library helps balance this tradeoff by enabling any of the array parameters to be compile time constants, but not require it. Which parameters should be made into compile time constants will vary depending on the use case. A common case is to make the innermost dimension have stride 1: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  using my_dense_3d_shape_type = shape&lt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;      dim&lt;/*Min=*/dynamic, /*Extent=*/dynamic, /*Stride=*/1&gt;,</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;      dim&lt;&gt;,</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      dim&lt;&gt;&gt;;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  array&lt;char, my_dense_3d_shape_type&gt; my_dense_array({16, 3, 3});</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  for (auto x : my_dense_array.x()) {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    // The compiler knows that each loop iteration accesses</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    // elements that are contiguous in memory for contiguous x.</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    my_dense_array(x, y, z) = 0;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  }</div></div><!-- fragment --><p>A dimension with unknown min and extent, and stride 1, is common enough that it has a built-in alias <code>dense_dim&lt;&gt;</code>, and shapes with a dense first dimension are common enough that shapes and arrays have the following built-in aliases:</p><ul>
<li><code>dense_shape&lt;N&gt;</code>, an N-dimensional shape with the first dimension being dense.</li>
<li><code>dense_array_ref&lt;T, N&gt;</code> and <code>dense_array&lt;T, N, Allocator&gt;</code>, N-dimensional arrays with a shape of <code>dense_shape&lt;N&gt;</code>.</li>
</ul>
<p>There are other common examples that are easy to support. A very common array is an image where 3-channel RGB or 4-channel RGBA pixels are stored together in a 'chunky' format. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;template &lt;int Channels, int XStride = Channels&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;using chunky_image_shape = shape&lt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    strided_dim&lt;/*Stride=*/XStride&gt;,</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    dim&lt;&gt;,</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    dense_dim&lt;/*Min=*/0, /*Extent=*/Channels&gt;&gt;;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;array&lt;uint8_t, chunky_image_shape&lt;3&gt;&gt; my_chunky_image({1920, 1080, {}});</div></div><!-- fragment --><p><code>strided_dim&lt;&gt;</code> is another alias for <code>dim&lt;&gt;</code> where the min and extent are unknown, and the stride may be a compile-time constant. <a href="include/array/image.h"><code>image.h</code></a> is a small helper library of typical image shape and object types defined using arrays, including <code>chunky_image_shape</code>.</p>
<p>Another common example is matrices indexed <code>(row, column)</code> with the column dimension stored densely: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  using matrix_shape = shape&lt;dim&lt;&gt;, dense_dim&lt;&gt;&gt;;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  array&lt;double, matrix_shape&gt; my_matrix({10, 4});</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  for (auto i : my_matrix.i()) {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    for (auto j : my_matrix.j()) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      // This loop ordering is efficient for this type.</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;      my_matrix(i, j) = 0.0;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    }</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  }</div></div><!-- fragment --><p>There are also many use cases for matrices with small constant sizes. This library provides <code>auto_allocator&lt;T, N&gt;</code>, an <code>std::allocator</code> compatible allocator that only allocates buffers of <code>N</code> small fixed sized objects with automatic storage. This makes it possible to define a small matrix type that will not use any dynamic memory allocation: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;template &lt;int M, int N&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;using small_matrix_shape = shape&lt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    dim&lt;0, M&gt;,</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    dense_dim&lt;0, N&gt;&gt;;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;template &lt;typename T, int M, int N&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;using small_matrix = array&lt;T, small_matrix_shape&lt;M, N&gt;, auto_allocator&lt;T, M*N&gt;&gt;;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;small_matrix&lt;float, 4, 4&gt; my_small_matrix;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;// my_small_matrix is only one fixed size allocation, no new/delete calls</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;// happen. sizeof(small_matrix) = sizeof(float) * 4 * 4 + (overhead)</div></div><!-- fragment --><p><a href="include/array/matrix.h"><code>matrix.h</code></a> is a small helper library of typical matrix shape and object types defined using arrays, including the examples above.</p>
<h3>Slicing, cropping, and splitting</h3>
<p>Shapes and arrays can be sliced and cropped using <code>interval&lt;Min, Extent&gt;</code> objects, which are similar to <code>dim&lt;&gt;</code>s. They can have either a compile-time constant or runtime valued min and extent. <code>range(begin, end)</code> is a helper functions to construct an <code>interval</code>. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  // Slicing</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  array_ref_of_rank&lt;int, 2&gt; channel1 = my_array(_, _, 1);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  array_ref_of_rank&lt;int, 1&gt; row4_channel2 = my_array(_, 4, 2);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  // Cropping</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  array_ref_of_rank&lt;int, 3&gt; top_left = my_array(interval&lt;&gt;{0, 2}, interval&lt;&gt;{0, 4}, _);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  array_ref_of_rank&lt;int, 2&gt; center_channel0 = my_array(interval&lt;&gt;{1, 2}, interval&lt;&gt;{2, 4}, 0);</div></div><!-- fragment --><p> The <code>_</code> or <code>all</code> constants are placeholders indicating the entire dimension should be preserved. Dimensions that are sliced are removed from the shape of the array.</p>
<p>When iterating a <code>dim</code>, it is possible to <code>split</code> it first by either a compile-time constant or a runtime-valued split factor. A split <code>dim</code> produces an iterator range that produces <code>interval&lt;&gt;</code> objects. This allows easy tiling of algorithms: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  constexpr index_t x_split_factor = 3;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  const index_t y_split_factor = 5;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  for (auto yo : split(my_array.y(), y_split_factor)) {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    for (auto xo : split&lt;x_split_factor&gt;(my_array.x())) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      auto tile = my_array(xo, yo, _);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;      for (auto x : tile.x()) {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        // The compiler knows this loop has a fixed extent x_split_factor!</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        tile(x, y, z) = x;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;      }</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    }</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  }</div></div><!-- fragment --><p>Both loops have extents that are not divided by their split factors. To avoid generating an <code>array_ref</code> referencing data out of bounds of the original array, the split iterators modify the last iteration. The behavior of each kind of split is different:</p><ul>
<li>Because the extent of <code>yo</code> can vary, it is reduced on the last iteration. This strategy can accommodate dimensions of any extent.</li>
<li>Because the extent of <code>xo</code> must be a constant, the last iteration will be shifted to overlap the previous iteration. This strategy requires the extent of the dimension being split is greater than the split factor (but not a multiple!)</li>
</ul>
<p>Compile-time constant split factors produce ranges with compile-time extents, and shapes and arrays cropped with these ranges will have a corresponding <code>dim&lt;&gt;</code> with a compile-time constant extent. This allows potentially significant optimizations to be expressed relatively easily!</p>
<h3>Einstein reductions</h3>
<p>The <a href="include/array/ein_reduce.h"><code>ein_reduce.h</code></a> header provides <a href="https://en.wikipedia.org/wiki/Einstein_notation">Einstein notation</a> reductions and summation helpers, similar to <a href="https://numpy.org/doc/stable/reference/generated/numpy.einsum.html">np.einsum</a> or <a href="https://www.tensorflow.org/api_docs/python/tf/einsum">tf.einsum</a>. These are zero-cost abstractions for describing loops that allow expressing a wide variety of array operations. Einstein notation expression operands are constructed using the <code>ein&lt;i, j, ...&gt;(x)</code> helper function, where <code>x</code> can be any callable object, including an <code>array&lt;&gt;</code> or <code>array_ref&lt;&gt;</code>. <code>i, j, ...</code> are <code>constexpr</code> integers indicating which dimensions of the reduction operation are used to evaluate <code>x</code>. Therefore, the number of arguments of <code>x</code> must match the number of dimensions provided to <code>ein</code>. Operands can be combined into larger expressions using typical binary operators.</p>
<p>Einstein notation expressions can be evaluated using one of the following functions:</p><ul>
<li><code>ein_reduce(expression)</code>, evaluate an arbitrary Einstein notation <code>expression</code>.</li>
<li><code>lhs = make_ein_sum&lt;T, i, j, ...&gt;(rhs)</code>, evaluate the summation <code>ein&lt;i, j, ...&gt;(lhs) += rhs</code>, and return <code>lhs</code>. The shape of <code>lhs</code> is inferred from the expression.</li>
</ul>
<p>Here are some examples using these reduction operations to compute summations: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  // Name the dimensions we use in Einstein reductions.</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  enum { i = 0, j = 1, k = 2, l = 3 };</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  // Dot product dot1 = dot2 = x.y:</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  vector&lt;float&gt; x({10});</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  vector&lt;float&gt; y({10});</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  float dot1 = make_ein_sum&lt;float&gt;(ein&lt;i&gt;(x) * ein&lt;i&gt;(y));</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  float dot2 = 0.0f;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  ein_reduce(ein(dot2) += ein&lt;i&gt;(x) * ein&lt;i&gt;(y));</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  // Matrix multiply C1 = C2 = A*B:</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  matrix&lt;float&gt; A({10, 10});</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  matrix&lt;float&gt; B({10, 15});</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  matrix&lt;float&gt; C1({10, 15});</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  fill(C1, 0.0f);</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  ein_reduce(ein&lt;i, j&gt;(C1) += ein&lt;i, k&gt;(A) * ein&lt;k, j&gt;(B));</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  auto C2 = make_ein_sum&lt;float, i, j&gt;(ein&lt;i, k&gt;(A) * ein&lt;k, j&gt;(B));</div></div><!-- fragment --><p>We can use arbitrary functions as expression operands: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  // Cross product array crosses_n = x_n x y_n:</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  using vector_array = array&lt;float, shape&lt;dim&lt;0, 3&gt;, dense_dim&lt;&gt;&gt;&gt;;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  vector_array xs({3, 100});</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  vector_array ys({3, 100});</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  vector_array crosses({3, 100});</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  auto epsilon3 = [](int i, int j, int k) { return sgn(j - i) * sgn(k - i) * sgn(k - j); };</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  ein_reduce(ein&lt;i, l&gt;(crosses) += ein&lt;i, j, k&gt;(epsilon3) * ein&lt;j, l&gt;(xs) * ein&lt;k, l&gt;(ys));</div></div><!-- fragment --><p>These operations generally produce loop nests that are as readily optimized by the compiler as hand-written loops. In this example, <code>crosses</code>, <code>xs</code>, and <code>ys</code> have shape <code>shape&lt;dim&lt;0, 3&gt;, dense_dim&lt;&gt;&gt;</code>, so the compiler will see small constant loops and likely be able to optimize this to similar efficiency as hand-written code, by unrolling and evaluating the function at compile time. The compiler also should be able to efficiently vectorize the <code>l</code> dimension of the <code>ein_reduce</code>, because that dimension has a constant stride 1.</p>
<p>The expression can be another kind of reduction, or not a reduction at all: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  // Matrix transpose AT = A^T:</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  matrix&lt;float&gt; AT({10, 10});</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  ein_reduce(ein&lt;i, j&gt;(AT) = ein&lt;j, i&gt;(A));</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  // Maximum of each x-y plane of a 3D volume:</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  dense_array&lt;float, 3&gt; volume({8, 12, 20});</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  dense_array&lt;float, 1&gt; max_xy({20});</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  auto r = ein&lt;k&gt;(max_xy);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  ein_reduce(r = max(r, ein&lt;i, j, k&gt;(volume)));</div></div><!-- fragment --><p>Reductions can have a mix of result and operand types: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  // Compute X1 = X2 = DFT[x]:</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  using complex = std::complex&lt;float&gt;;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  dense_array&lt;complex, 2&gt; W({10, 10});</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  for_all_indices(W.shape(), [&amp;](int j, int k) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    W(j, k) = exp(-2.0f * pi * complex(0, 1) * (static_cast&lt;float&gt;(j * k) / 10));</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  });</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  // Using `make_ein_sum`, returning the result:</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  auto X1 = make_ein_sum&lt;complex, j&gt;(ein&lt;j, k&gt;(W) * ein&lt;k&gt;(x));</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  // Using `ein_reduce`, computing the result in place:</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  vector&lt;complex&gt; X2({10}, 0.0f);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  ein_reduce(ein&lt;j&gt;(X2) += ein&lt;j, k&gt;(W) * ein&lt;k&gt;(x));</div></div><!-- fragment --><p>These reductions also compose well with loop transformations like <code>split</code> and array operations like <a href="#slicing-cropping-and-splitting">slicing and cropping</a>. For example, a matrix multiplication can be tiled like so: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  // Adjust this depending on the target architecture. For AVX2, vectors are 256-bit.</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  constexpr index_t vector_size = 32 / sizeof(float);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  // We want the tiles to be big without spilling the accumulators to the stack.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  constexpr index_t tile_rows = 4;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  constexpr index_t tile_cols = vector_size * 3;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  for (auto io : split&lt;tile_rows&gt;(C.i())) {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    for (auto jo : split&lt;tile_cols&gt;(C.j())) {</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;      auto C_ijo = C(io, jo);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;      fill(C_ijo, 0.0f);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;      ein_reduce(ein&lt;i, j&gt;(C_ijo) += ein&lt;i, k&gt;(A) * ein&lt;k, j&gt;(B));</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    }</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  }</div></div><!-- fragment --><p>This generates the following machine code(*) for the inner loop using clang 18 with -O2 -ffast-math: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;vbroadcastss  (%rsi,%rdi,4), %ymm12</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;vmovups -64(%r12,%r15,4), %ymm13</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;vmovups -32(%r12,%r15,4), %ymm14</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;vmovups (%r12,%r15,4), %ymm15</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;addq  %rbx, %r15</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;vfmadd231ps %ymm12, %ymm13, %ymm11</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;vfmadd231ps %ymm12, %ymm14, %ymm10</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;vfmadd231ps %ymm12, %ymm15, %ymm9</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;vbroadcastss  (%r8,%rdi,4), %ymm12</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;vfmadd231ps %ymm12, %ymm13, %ymm8</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;vfmadd231ps %ymm12, %ymm14, %ymm7</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;vfmadd231ps %ymm12, %ymm15, %ymm6</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;vbroadcastss  (%r10,%rdi,4), %ymm12</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;vfmadd231ps %ymm12, %ymm13, %ymm5</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;vfmadd231ps %ymm12, %ymm14, %ymm4</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;vfmadd231ps %ymm12, %ymm15, %ymm3</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;vbroadcastss  (%rdx,%rdi,4), %ymm12</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;incq  %rdi</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;vfmadd231ps %ymm13, %ymm12, %ymm2</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;vfmadd231ps %ymm14, %ymm12, %ymm1</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;vfmadd231ps %ymm12, %ymm15, %ymm0</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;cmpq  %rdi, %r13</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;jne .LBB8_12</div></div><!-- fragment --><p> This is <b>40-50x</b> faster than a naive C implementation of nested loops on my machine, and it should be within a factor of 2 of the peak possible performance. A <a href="examples/linear_algebra/matrix.cpp#L265-L271">similar example</a> that is only a little more complicated achieves around 90% of the peak possible performance.</p>
<p>(*) Unfortunately, this doesn't generate performant code currently and requires a few tweaks to work around an <a href="https://bugs.llvm.org/show_bug.cgi?id=45863">issue</a> in LLVM. See the <a href="examples/linear_algebra/matrix.cpp">matrix example</a> for the code that produces the above assembly. To summarise, it is currently necessary to perform the accumulation into a temporary buffer instead of accumulating directly into the output.</p>
<h3>CUDA support</h3>
<p>Most of the functions in this library are marked with <code>__device__</code>, enabling them to be used in CUDA code. This includes <code>array_ref&lt;T, Shape&gt;</code> and most of its helper functions. The exceptions to this are functions and classes that allocate memory, primarily <code>array&lt;T, Shape, Alloc&gt;</code>.</p>
<h3>Try it on Compiler Explorer</h3>
<p>This library is available on <a href="https://godbolt.org/">Compiler Explorer</a> as <code>Array</code>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
