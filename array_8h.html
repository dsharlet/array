<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>array: include/array/array.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">array
   </div>
   <div id="projectbrief">C++ library for multi-dimensional arrays</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_717b3188b45e89f652d81ea10aa11b1d.html">array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">array.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main header for array library.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;array&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstdio&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
</div>
<p><a href="array_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnda_1_1index__iterator.html">index_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnda_1_1dim.html">dim&lt; Min_, Extent_, Stride_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnda_1_1interval.html">interval&lt; Min_, Extent_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnda_1_1dim.html">dim&lt; Min_, Extent_, Stride_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnda_1_1shape.html">shape&lt; Dims &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnda_1_1shape.html">shape&lt; Dims &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnda_1_1shape__traits.html">shape_traits&lt; Shape &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnda_1_1copy__shape__traits.html">copy_shape_traits&lt; ShapeSrc, ShapeDst &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnda_1_1array__ref.html">array_ref&lt; T, Shape &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnda_1_1array.html">array&lt; T, Shape, Alloc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnda_1_1array__ref.html">array_ref&lt; T, Shape &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnda_1_1array.html">array&lt; T, Shape, Alloc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnda_1_1auto__allocator.html">auto_allocator&lt; T, N, Alignment, BaseAlloc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnda_1_1uninitialized__allocator.html">uninitialized_allocator&lt; BaseAlloc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4a70b88b81e58d7815f3b85332dc2240"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a70b88b81e58d7815f3b85332dc2240"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NDARRAY_INLINE</b>&#160;&#160;&#160;inline</td></tr>
<tr class="separator:a4a70b88b81e58d7815f3b85332dc2240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfa80bd962d6e1436c4899d426d2d89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bfa80bd962d6e1436c4899d426d2d89"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NDARRAY_UNIQUE</b>&#160;&#160;&#160;static</td></tr>
<tr class="separator:a4bfa80bd962d6e1436c4899d426d2d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3370e99aa4fa55d43da43f48190fb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b3370e99aa4fa55d43da43f48190fb1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NDARRAY_HOST_DEVICE</b></td></tr>
<tr class="separator:a4b3370e99aa4fa55d43da43f48190fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e004e72af7675bc11d5d352a4d590f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56e004e72af7675bc11d5d352a4d590f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NDARRAY_RESTRICT</b></td></tr>
<tr class="separator:a56e004e72af7675bc11d5d352a4d590f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499d63878f0d433d86001b12637cce78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a499d63878f0d433d86001b12637cce78"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NDARRAY_PRINT_ERR</b>(...)&#160;&#160;&#160;fprintf(stderr, __VA_ARGS__)</td></tr>
<tr class="separator:a499d63878f0d433d86001b12637cce78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1e1c6b80ab24f42d474c9dff815861"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c1e1c6b80ab24f42d474c9dff815861"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NDARRAY_INDEX_T_FMT</b>&#160;&#160;&#160;&quot;%td&quot;</td></tr>
<tr class="separator:a5c1e1c6b80ab24f42d474c9dff815861"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a801d6a451a01953ef8cbae6feb6a3638"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a801d6a451a01953ef8cbae6feb6a3638"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_t</b> = std::size_t</td></tr>
<tr class="separator:a801d6a451a01953ef8cbae6feb6a3638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26493ae85adc5b160363a05a6cd4f11e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a26493ae85adc5b160363a05a6cd4f11e">index_t</a> = std::ptrdiff_t</td></tr>
<tr class="separator:a26493ae85adc5b160363a05a6cd4f11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211cabf0fcc1a09e896e0af76704dd6f"><td class="memTemplParams" colspan="2">template&lt;index_t Extent&gt; </td></tr>
<tr class="memitem:a211cabf0fcc1a09e896e0af76704dd6f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a211cabf0fcc1a09e896e0af76704dd6f">fixed_interval</a> = interval&lt; dynamic, Extent &gt;</td></tr>
<tr class="separator:a211cabf0fcc1a09e896e0af76704dd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0209166945d62a1629fc11e434ac98"><td class="memTemplParams" colspan="2">template&lt;index_t Extent, index_t Stride = dynamic&gt; </td></tr>
<tr class="memitem:adb0209166945d62a1629fc11e434ac98"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#adb0209166945d62a1629fc11e434ac98">fixed_dim</a> = dim&lt; dynamic, Extent, Stride &gt;</td></tr>
<tr class="separator:adb0209166945d62a1629fc11e434ac98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c87b9adb5a4f4ad386e78145eabc2f"><td class="memTemplParams" colspan="2">template&lt;index_t Min = dynamic, index_t Extent = dynamic&gt; </td></tr>
<tr class="memitem:a00c87b9adb5a4f4ad386e78145eabc2f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a00c87b9adb5a4f4ad386e78145eabc2f">dense_dim</a> = dim&lt; Min, Extent, 1 &gt;</td></tr>
<tr class="separator:a00c87b9adb5a4f4ad386e78145eabc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9025cb1177525c1b8587b589ca647e4e"><td class="memTemplParams" colspan="2">template&lt;index_t Stride&gt; </td></tr>
<tr class="memitem:a9025cb1177525c1b8587b589ca647e4e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a9025cb1177525c1b8587b589ca647e4e">strided_dim</a> = dim&lt; dynamic, dynamic, Stride &gt;</td></tr>
<tr class="separator:a9025cb1177525c1b8587b589ca647e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c13f3faa99c074549d5f2265cc7ba1d"><td class="memTemplParams" colspan="2">template&lt;index_t Min = dynamic, index_t Extent = dynamic&gt; </td></tr>
<tr class="memitem:a1c13f3faa99c074549d5f2265cc7ba1d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a1c13f3faa99c074549d5f2265cc7ba1d">broadcast_dim</a> = dim&lt; Min, Extent, 0 &gt;</td></tr>
<tr class="separator:a1c13f3faa99c074549d5f2265cc7ba1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7866b82526d5276e559a3bc02e09686"><td class="memTemplParams" colspan="2">template&lt;size_t Rank&gt; </td></tr>
<tr class="memitem:ad7866b82526d5276e559a3bc02e09686"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#ad7866b82526d5276e559a3bc02e09686">index_of_rank</a> = internal::tuple_of_n&lt; index_t, Rank &gt;</td></tr>
<tr class="separator:ad7866b82526d5276e559a3bc02e09686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e0c3b2fc19efea03b595a9fbe2ba23"><td class="memTemplParams" colspan="2">template&lt;size_t Rank&gt; </td></tr>
<tr class="memitem:a61e0c3b2fc19efea03b595a9fbe2ba23"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a61e0c3b2fc19efea03b595a9fbe2ba23">shape_of_rank</a> = decltype(make_shape_from_tuple(internal::tuple_of_n&lt; dim&lt;&gt;, Rank &gt;()))</td></tr>
<tr class="separator:a61e0c3b2fc19efea03b595a9fbe2ba23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa200a0a9e702ec0241adb18f351acbe2"><td class="memTemplParams" colspan="2">template&lt;size_t Rank&gt; </td></tr>
<tr class="memitem:aa200a0a9e702ec0241adb18f351acbe2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#aa200a0a9e702ec0241adb18f351acbe2">dense_shape</a> = decltype(internal::make_default_dense_shape&lt; Rank &gt;())</td></tr>
<tr class="separator:aa200a0a9e702ec0241adb18f351acbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b935efb37c2765a3aae7b2ecaeec26"><td class="memTemplParams" colspan="2">template&lt;index_t... Extents&gt; </td></tr>
<tr class="memitem:ac7b935efb37c2765a3aae7b2ecaeec26"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#ac7b935efb37c2765a3aae7b2ecaeec26">fixed_dense_shape</a> = decltype(make_shape_from_tuple(internal::make_compact_dims&lt; 1 &gt;(dim&lt; 0, Extents &gt;()...)))</td></tr>
<tr class="separator:ac7b935efb37c2765a3aae7b2ecaeec26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2753cd25cae12f5daacb3bc8492b57"><td class="memTemplParams" colspan="2"><a class="anchor" id="aed2753cd25cae12f5daacb3bc8492b57"></a>
template&lt;class T , class Shape &gt; </td></tr>
<tr class="memitem:aed2753cd25cae12f5daacb3bc8492b57"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>const_array_ref</b> = array_ref&lt; const T, Shape &gt;</td></tr>
<tr class="separator:aed2753cd25cae12f5daacb3bc8492b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edeffa5f4878abb67a08b3eccdc9d2a"><td class="memTemplParams" colspan="2">template&lt;class T , size_t Rank&gt; </td></tr>
<tr class="memitem:a4edeffa5f4878abb67a08b3eccdc9d2a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a4edeffa5f4878abb67a08b3eccdc9d2a">array_ref_of_rank</a> = array_ref&lt; T, shape_of_rank&lt; Rank &gt;&gt;</td></tr>
<tr class="separator:a4edeffa5f4878abb67a08b3eccdc9d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6591b118496d2e3166b2faea8ef8c340"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6591b118496d2e3166b2faea8ef8c340"></a>
template&lt;class T , size_t Rank&gt; </td></tr>
<tr class="memitem:a6591b118496d2e3166b2faea8ef8c340"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>const_array_ref_of_rank</b> = array_ref_of_rank&lt; const T, Rank &gt;</td></tr>
<tr class="separator:a6591b118496d2e3166b2faea8ef8c340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbaedd9bb2f66c68d0dbc60fefafde1"><td class="memTemplParams" colspan="2">template&lt;class T , size_t Rank&gt; </td></tr>
<tr class="memitem:a3bbaedd9bb2f66c68d0dbc60fefafde1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a3bbaedd9bb2f66c68d0dbc60fefafde1">dense_array_ref</a> = array_ref&lt; T, dense_shape&lt; Rank &gt;&gt;</td></tr>
<tr class="separator:a3bbaedd9bb2f66c68d0dbc60fefafde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e88e25957bfc0e804a70a982298c40e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6e88e25957bfc0e804a70a982298c40e"></a>
template&lt;class T , size_t Rank&gt; </td></tr>
<tr class="memitem:a6e88e25957bfc0e804a70a982298c40e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>const_dense_array_ref</b> = dense_array_ref&lt; const T, Rank &gt;</td></tr>
<tr class="separator:a6e88e25957bfc0e804a70a982298c40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3848811e2aae330fb669a23f30cd2e"><td class="memTemplParams" colspan="2">template&lt;class T , size_t Rank, class Alloc  = std::allocator&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aec3848811e2aae330fb669a23f30cd2e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#aec3848811e2aae330fb669a23f30cd2e">array_of_rank</a> = array&lt; T, shape_of_rank&lt; Rank &gt;, Alloc &gt;</td></tr>
<tr class="separator:aec3848811e2aae330fb669a23f30cd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd5dd48fcb68ce48daff5d746cb297c"><td class="memTemplParams" colspan="2">template&lt;class T , size_t Rank, class Alloc  = std::allocator&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a6fd5dd48fcb68ce48daff5d746cb297c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a6fd5dd48fcb68ce48daff5d746cb297c">dense_array</a> = array&lt; T, dense_shape&lt; Rank &gt;, Alloc &gt;</td></tr>
<tr class="separator:a6fd5dd48fcb68ce48daff5d746cb297c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaf81b16b0c4bc1c603dbb31f640b23"><td class="memTemplParams" colspan="2">template&lt;class T , class  = std::enable_if_t&lt;std::is_trivial&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a8aaf81b16b0c4bc1c603dbb31f640b23"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a8aaf81b16b0c4bc1c603dbb31f640b23">uninitialized_std_allocator</a> = uninitialized_allocator&lt; std::allocator&lt; T &gt;&gt;</td></tr>
<tr class="separator:a8aaf81b16b0c4bc1c603dbb31f640b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574fafc712a9b945bad45a98e95a5bcf"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N, size_t Alignment = sizeof(T), class  = std::enable_if_t&lt;std::is_trivial&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a574fafc712a9b945bad45a98e95a5bcf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a574fafc712a9b945bad45a98e95a5bcf">uninitialized_auto_allocator</a> = uninitialized_allocator&lt; auto_allocator&lt; T, N, Alignment &gt;&gt;</td></tr>
<tr class="separator:a574fafc712a9b945bad45a98e95a5bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaaa66a68a53c7780294f443c9da40fb8"><td class="memItemLeft" align="right" valign="top">NDARRAY_INLINE NDARRAY_HOST_DEVICE interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#aaaa66a68a53c7780294f443c9da40fb8">range</a> (index_t begin, index_t end)</td></tr>
<tr class="separator:aaaa66a68a53c7780294f443c9da40fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d105a8703ae902af7c42780afa3032"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01d105a8703ae902af7c42780afa3032"></a>
NDARRAY_INLINE NDARRAY_HOST_DEVICE interval&#160;</td><td class="memItemRight" valign="bottom"><b>r</b> (index_t begin, index_t end)</td></tr>
<tr class="separator:a01d105a8703ae902af7c42780afa3032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e4d24524ff36ed841fa23295347628"><td class="memTemplParams" colspan="2">template&lt;index_t Extent&gt; </td></tr>
<tr class="memitem:a41e4d24524ff36ed841fa23295347628"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE fixed_interval&lt; Extent &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a41e4d24524ff36ed841fa23295347628">range</a> (index_t begin)</td></tr>
<tr class="separator:a41e4d24524ff36ed841fa23295347628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffd51d8cdc846bf914f2463d38bd927"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5ffd51d8cdc846bf914f2463d38bd927"></a>
template&lt;index_t Extent&gt; </td></tr>
<tr class="memitem:a5ffd51d8cdc846bf914f2463d38bd927"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE fixed_interval&lt; Extent &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>r</b> (index_t begin)</td></tr>
<tr class="separator:a5ffd51d8cdc846bf914f2463d38bd927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074fffb7cad44b70b9a5dc0793560dfd"><td class="memTemplParams" colspan="2">template&lt;index_t Min, index_t Extent&gt; </td></tr>
<tr class="memitem:a074fffb7cad44b70b9a5dc0793560dfd"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE index_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a074fffb7cad44b70b9a5dc0793560dfd">begin</a> (const interval&lt; Min, Extent &gt; &amp;d)</td></tr>
<tr class="separator:a074fffb7cad44b70b9a5dc0793560dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962e3e063e6e02331b904b555c5021e8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a962e3e063e6e02331b904b555c5021e8"></a>
template&lt;index_t Min, index_t Extent&gt; </td></tr>
<tr class="memitem:a962e3e063e6e02331b904b555c5021e8"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE index_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>end</b> (const interval&lt; Min, Extent &gt; &amp;d)</td></tr>
<tr class="separator:a962e3e063e6e02331b904b555c5021e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191ec3144f7249e6f2679ce4648e3c67"><td class="memItemLeft" align="right" valign="top">NDARRAY_INLINE NDARRAY_HOST_DEVICE index_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a191ec3144f7249e6f2679ce4648e3c67">clamp</a> (index_t x, index_t min, index_t max)</td></tr>
<tr class="separator:a191ec3144f7249e6f2679ce4648e3c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14484b48d68ae36f12f40248f78f2b43"><td class="memTemplParams" colspan="2">template&lt;class Range &gt; </td></tr>
<tr class="memitem:a14484b48d68ae36f12f40248f78f2b43"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE index_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a14484b48d68ae36f12f40248f78f2b43">clamp</a> (index_t x, const Range &amp;r)</td></tr>
<tr class="separator:a14484b48d68ae36f12f40248f78f2b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d05a3211e2c3a5e86eb63559ae4a7ca"><td class="memTemplParams" colspan="2">template&lt;index_t InnerExtent, index_t Min, index_t Extent&gt; </td></tr>
<tr class="memitem:a3d05a3211e2c3a5e86eb63559ae4a7ca"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE internal::split_result&lt; InnerExtent &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a3d05a3211e2c3a5e86eb63559ae4a7ca">split</a> (const interval&lt; Min, Extent &gt; &amp;v)</td></tr>
<tr class="separator:a3d05a3211e2c3a5e86eb63559ae4a7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5ce209c37c84de2851cdd13d7bf9f6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d5ce209c37c84de2851cdd13d7bf9f6"></a>
template&lt;index_t InnerExtent, index_t Min, index_t Extent, index_t Stride&gt; </td></tr>
<tr class="memitem:a0d5ce209c37c84de2851cdd13d7bf9f6"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE internal::split_result&lt; InnerExtent &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>split</b> (const dim&lt; Min, Extent, Stride &gt; &amp;v)</td></tr>
<tr class="separator:a0d5ce209c37c84de2851cdd13d7bf9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad010fde354a851daf6ad43533c758ca"><td class="memTemplParams" colspan="2">template&lt;index_t Min, index_t Extent&gt; </td></tr>
<tr class="memitem:aad010fde354a851daf6ad43533c758ca"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE internal::split_result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#aad010fde354a851daf6ad43533c758ca">split</a> (const interval&lt; Min, Extent &gt; &amp;v, index_t inner_extent)</td></tr>
<tr class="separator:aad010fde354a851daf6ad43533c758ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2538843fe5c47ec83739970b2c02bf4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab2538843fe5c47ec83739970b2c02bf4"></a>
template&lt;index_t Min, index_t Extent, index_t Stride&gt; </td></tr>
<tr class="memitem:ab2538843fe5c47ec83739970b2c02bf4"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE internal::split_result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>split</b> (const dim&lt; Min, Extent, Stride &gt; &amp;v, index_t inner_extent)</td></tr>
<tr class="separator:ab2538843fe5c47ec83739970b2c02bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc77f5082e94f21c95849a1eefd016c3"><td class="memTemplParams" colspan="2">template&lt;class... Dims&gt; </td></tr>
<tr class="memitem:acc77f5082e94f21c95849a1eefd016c3"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#acc77f5082e94f21c95849a1eefd016c3">make_shape</a> (Dims...dims)</td></tr>
<tr class="separator:acc77f5082e94f21c95849a1eefd016c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738334ed47c7e47121a120c7e73e9c02"><td class="memTemplParams" colspan="2"><a class="anchor" id="a738334ed47c7e47121a120c7e73e9c02"></a>
template&lt;class... Dims&gt; </td></tr>
<tr class="memitem:a738334ed47c7e47121a120c7e73e9c02"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE shape&lt; Dims... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_shape_from_tuple</b> (const std::tuple&lt; Dims... &gt; &amp;dims)</td></tr>
<tr class="separator:a738334ed47c7e47121a120c7e73e9c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e4d426486c09a1a9520aa95975be5a"><td class="memTemplParams" colspan="2">template&lt;size_t... DimIndices, class... Dims, class  = internal::enable_if_permutation&lt;sizeof...(DimIndices), DimIndices...&gt;&gt; </td></tr>
<tr class="memitem:af2e4d426486c09a1a9520aa95975be5a"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#af2e4d426486c09a1a9520aa95975be5a">transpose</a> (const shape&lt; Dims... &gt; &amp;shape)</td></tr>
<tr class="separator:af2e4d426486c09a1a9520aa95975be5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac330ca487f4b29eb13861850de98a38f"><td class="memTemplParams" colspan="2">template&lt;size_t... DimIndices, class... Dims&gt; </td></tr>
<tr class="memitem:ac330ca487f4b29eb13861850de98a38f"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#ac330ca487f4b29eb13861850de98a38f">reorder</a> (const shape&lt; Dims... &gt; &amp;shape)</td></tr>
<tr class="separator:ac330ca487f4b29eb13861850de98a38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5aeff46be2236fb32a203dfd2c0f6fe"><td class="memTemplParams" colspan="2">template&lt;class Shape &gt; </td></tr>
<tr class="memitem:ab5aeff46be2236fb32a203dfd2c0f6fe"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#ab5aeff46be2236fb32a203dfd2c0f6fe">make_compact</a> (const Shape &amp;s)</td></tr>
<tr class="separator:ab5aeff46be2236fb32a203dfd2c0f6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68a87c9486d77bb1c2c8bc8f3587290"><td class="memTemplParams" colspan="2">template&lt;class ShapeDst , class ShapeSrc , class  = internal::enable_if_shapes_compatible&lt;ShapeSrc, ShapeDst&gt;&gt; </td></tr>
<tr class="memitem:ac68a87c9486d77bb1c2c8bc8f3587290"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#ac68a87c9486d77bb1c2c8bc8f3587290">is_compatible</a> (const ShapeSrc &amp;src)</td></tr>
<tr class="separator:ac68a87c9486d77bb1c2c8bc8f3587290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa632dc4e183e8b352b3b5fc49740f5e5"><td class="memTemplParams" colspan="2">template&lt;class ShapeDst , class ShapeSrc , class  = internal::enable_if_shapes_explicitly_compatible&lt;ShapeDst, ShapeSrc&gt;&gt; </td></tr>
<tr class="memitem:aa632dc4e183e8b352b3b5fc49740f5e5"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE ShapeDst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#aa632dc4e183e8b352b3b5fc49740f5e5">convert_shape</a> (const ShapeSrc &amp;src)</td></tr>
<tr class="separator:aa632dc4e183e8b352b3b5fc49740f5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef30cae2d67c4103d15cfbcfff0f349a"><td class="memTemplParams" colspan="2">template&lt;class ShapeDst , class ShapeSrc , class  = internal::enable_if_shapes_explicitly_compatible&lt;ShapeSrc, ShapeDst&gt;&gt; </td></tr>
<tr class="memitem:aef30cae2d67c4103d15cfbcfff0f349a"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#aef30cae2d67c4103d15cfbcfff0f349a">is_explicitly_compatible</a> (const ShapeSrc &amp;src)</td></tr>
<tr class="separator:aef30cae2d67c4103d15cfbcfff0f349a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf31907f3bad61a417e225e5e135b7df"><td class="memTemplParams" colspan="2">template&lt;class Shape , class Fn , class  = internal::enable_if_callable&lt;Fn, typename Shape::index_type&gt;&gt; </td></tr>
<tr class="memitem:acf31907f3bad61a417e225e5e135b7df"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_UNIQUE NDARRAY_HOST_DEVICE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#acf31907f3bad61a417e225e5e135b7df">for_each_index_in_order</a> (const Shape &amp;shape, Fn &amp;&amp;fn)</td></tr>
<tr class="separator:acf31907f3bad61a417e225e5e135b7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167f8a6ef8a7434a1951662d4469a8d4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a167f8a6ef8a7434a1951662d4469a8d4"></a>
template&lt;class Shape , class Ptr , class Fn , class  = internal::enable_if_callable&lt;Fn, typename std::remove_pointer&lt;Ptr&gt;::type&amp;&gt;&gt; </td></tr>
<tr class="memitem:a167f8a6ef8a7434a1951662d4469a8d4"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_UNIQUE NDARRAY_HOST_DEVICE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_value_in_order</b> (const Shape &amp;shape, Ptr base, Fn &amp;&amp;fn)</td></tr>
<tr class="separator:a167f8a6ef8a7434a1951662d4469a8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926d23314527bd0010642a211ed7b146"><td class="memTemplParams" colspan="2">template&lt;class Shape , class ShapeA , class PtrA , class ShapeB , class PtrB , class Fn , class  = internal::enable_if_callable&lt;Fn, typename std::remove_pointer&lt;PtrA&gt;::type&amp;,        typename std::remove_pointer&lt;PtrB&gt;::type&amp;&gt;&gt; </td></tr>
<tr class="memitem:a926d23314527bd0010642a211ed7b146"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_UNIQUE NDARRAY_HOST_DEVICE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a926d23314527bd0010642a211ed7b146">for_each_value_in_order</a> (const Shape &amp;shape, const ShapeA &amp;shape_a, PtrA base_a, const ShapeB &amp;shape_b, PtrB base_b, Fn &amp;&amp;fn)</td></tr>
<tr class="separator:a926d23314527bd0010642a211ed7b146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedf4c4fe3a73f56a9f72ea34a2b6dad"><td class="memTemplParams" colspan="2">template&lt;size_t... LoopOrder, class Shape , class Fn , class  = internal::enable_if_callable&lt;Fn, typename Shape::index_type&gt;, std::enable_if_t&lt;(sizeof...(LoopOrder)==0), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aeedf4c4fe3a73f56a9f72ea34a2b6dad"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_UNIQUE NDARRAY_HOST_DEVICE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#aeedf4c4fe3a73f56a9f72ea34a2b6dad">for_each_index</a> (const Shape &amp;s, Fn &amp;&amp;fn)</td></tr>
<tr class="separator:aeedf4c4fe3a73f56a9f72ea34a2b6dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f20ca6122c42e0fec09ad05fcf70040"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0f20ca6122c42e0fec09ad05fcf70040"></a>
template&lt;size_t... LoopOrder, class Shape , class Fn , class  = internal::enable_if_applicable&lt;Fn, typename Shape::index_type&gt;, std::enable_if_t&lt;(sizeof...(LoopOrder)==0), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0f20ca6122c42e0fec09ad05fcf70040"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_UNIQUE NDARRAY_HOST_DEVICE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_all_indices</b> (const Shape &amp;s, Fn &amp;&amp;fn)</td></tr>
<tr class="separator:a0f20ca6122c42e0fec09ad05fcf70040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce93c483b477a4339650673058b60ba"><td class="memTemplParams" colspan="2">template&lt;class T , class Shape &gt; </td></tr>
<tr class="memitem:a1ce93c483b477a4339650673058b60ba"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE array_ref&lt; T, Shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a1ce93c483b477a4339650673058b60ba">make_array_ref</a> (T *base, const Shape &amp;shape)</td></tr>
<tr class="separator:a1ce93c483b477a4339650673058b60ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4a05d3f1a2fe00507e35bc10c516dd"><td class="memTemplParams" colspan="2">template&lt;class T , class Shape , class Alloc  = std::allocator&lt;T&gt;, class  = internal::enable_if_allocator&lt;Alloc&gt;&gt; </td></tr>
<tr class="memitem:a7b4a05d3f1a2fe00507e35bc10c516dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a7b4a05d3f1a2fe00507e35bc10c516dd">make_array</a> (const Shape &amp;shape, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="separator:a7b4a05d3f1a2fe00507e35bc10c516dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4b041c3e8c7a64d27e2b1cbae2c435"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5d4b041c3e8c7a64d27e2b1cbae2c435"></a>
template&lt;class T , class Shape , class Alloc  = std::allocator&lt;T&gt;, class  = internal::enable_if_allocator&lt;Alloc&gt;&gt; </td></tr>
<tr class="memitem:a5d4b041c3e8c7a64d27e2b1cbae2c435"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_array</b> (const Shape &amp;shape, const T &amp;value, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="separator:a5d4b041c3e8c7a64d27e2b1cbae2c435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842dbbf31ce75db1a54a7b498df53995"><td class="memTemplParams" colspan="2">template&lt;class T , class Shape , class Alloc &gt; </td></tr>
<tr class="memitem:a842dbbf31ce75db1a54a7b498df53995"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a842dbbf31ce75db1a54a7b498df53995">swap</a> (array&lt; T, Shape, Alloc &gt; &amp;a, array&lt; T, Shape, Alloc &gt; &amp;b)</td></tr>
<tr class="separator:a842dbbf31ce75db1a54a7b498df53995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b188d9c649d32dde879e9635553236"><td class="memTemplParams" colspan="2">template&lt;class TSrc , class TDst , class ShapeSrc , class ShapeDst , class  = internal::enable_if_shapes_copy_compatible&lt;ShapeDst, ShapeSrc&gt;&gt; </td></tr>
<tr class="memitem:a01b188d9c649d32dde879e9635553236"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a01b188d9c649d32dde879e9635553236">copy</a> (const array_ref&lt; TSrc, ShapeSrc &gt; &amp;src, const array_ref&lt; TDst, ShapeDst &gt; &amp;dst)</td></tr>
<tr class="separator:a01b188d9c649d32dde879e9635553236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f306aa5d3dd4f7ea552ea29be826be"><td class="memTemplParams" colspan="2"><a class="anchor" id="a98f306aa5d3dd4f7ea552ea29be826be"></a>
template&lt;class TSrc , class TDst , class ShapeSrc , class ShapeDst , class AllocDst , class  = internal::enable_if_shapes_copy_compatible&lt;ShapeDst, ShapeSrc&gt;&gt; </td></tr>
<tr class="memitem:a98f306aa5d3dd4f7ea552ea29be826be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy</b> (const array_ref&lt; TSrc, ShapeSrc &gt; &amp;src, array&lt; TDst, ShapeDst, AllocDst &gt; &amp;dst)</td></tr>
<tr class="separator:a98f306aa5d3dd4f7ea552ea29be826be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8726c7d64a6a9def8baf6fa0467a09"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4c8726c7d64a6a9def8baf6fa0467a09"></a>
template&lt;class TSrc , class TDst , class ShapeSrc , class ShapeDst , class AllocSrc , class  = internal::enable_if_shapes_copy_compatible&lt;ShapeDst, ShapeSrc&gt;&gt; </td></tr>
<tr class="memitem:a4c8726c7d64a6a9def8baf6fa0467a09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy</b> (const array&lt; TSrc, ShapeSrc, AllocSrc &gt; &amp;src, const array_ref&lt; TDst, ShapeDst &gt; &amp;dst)</td></tr>
<tr class="separator:a4c8726c7d64a6a9def8baf6fa0467a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c2aff106cf208544c8df6e90f91a25"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae6c2aff106cf208544c8df6e90f91a25"></a>
template&lt;class TSrc , class TDst , class ShapeSrc , class ShapeDst , class AllocSrc , class AllocDst , class  = internal::enable_if_shapes_copy_compatible&lt;ShapeDst, ShapeSrc&gt;&gt; </td></tr>
<tr class="memitem:ae6c2aff106cf208544c8df6e90f91a25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy</b> (const array&lt; TSrc, ShapeSrc, AllocSrc &gt; &amp;src, array&lt; TDst, ShapeDst, AllocDst &gt; &amp;dst)</td></tr>
<tr class="separator:ae6c2aff106cf208544c8df6e90f91a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c58e26230741655aa32a915844758b5"><td class="memTemplParams" colspan="2">template&lt;class T , class ShapeSrc , class Alloc  = std::allocator&lt;typename std::remove_const&lt;T&gt;::type&gt;&gt; </td></tr>
<tr class="memitem:a7c58e26230741655aa32a915844758b5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a7c58e26230741655aa32a915844758b5">make_copy</a> (const array_ref&lt; T, ShapeSrc &gt; &amp;src, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="separator:a7c58e26230741655aa32a915844758b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a2e5178d1fe569dfef90f80b9d1b38"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac9a2e5178d1fe569dfef90f80b9d1b38"></a>
template&lt;class T , class ShapeSrc , class AllocSrc , class AllocDst  = AllocSrc, class  = internal::enable_if_allocator&lt;AllocDst&gt;&gt; </td></tr>
<tr class="memitem:ac9a2e5178d1fe569dfef90f80b9d1b38"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_copy</b> (const array&lt; T, ShapeSrc, AllocSrc &gt; &amp;src, const AllocDst &amp;alloc=AllocDst())</td></tr>
<tr class="separator:ac9a2e5178d1fe569dfef90f80b9d1b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7d8cbb1a7ea679f9b0bba99d3d3150"><td class="memTemplParams" colspan="2">template&lt;class T , class ShapeSrc , class ShapeDst , class Alloc  = std::allocator&lt;typename std::remove_const&lt;T&gt;::type&gt;, class  = internal::enable_if_shapes_copy_compatible&lt;ShapeDst, ShapeSrc&gt;&gt; </td></tr>
<tr class="memitem:a9c7d8cbb1a7ea679f9b0bba99d3d3150"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a9c7d8cbb1a7ea679f9b0bba99d3d3150">make_copy</a> (const array_ref&lt; T, ShapeSrc &gt; &amp;src, const ShapeDst &amp;shape, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="separator:a9c7d8cbb1a7ea679f9b0bba99d3d3150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d09695545aee32e823752c483fcba58"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1d09695545aee32e823752c483fcba58"></a>
template&lt;class T , class ShapeSrc , class ShapeDst , class AllocSrc , class AllocDst  = AllocSrc, class  = internal::enable_if_shapes_copy_compatible&lt;ShapeDst, ShapeSrc&gt;&gt; </td></tr>
<tr class="memitem:a1d09695545aee32e823752c483fcba58"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_copy</b> (const array&lt; T, ShapeSrc, AllocSrc &gt; &amp;src, const ShapeDst &amp;shape, const AllocDst &amp;alloc=AllocDst())</td></tr>
<tr class="separator:a1d09695545aee32e823752c483fcba58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7f1b977c6d8977a608e96331cb44fd"><td class="memTemplParams" colspan="2">template&lt;class T , class Shape , class Alloc  = std::allocator&lt;typename std::remove_const&lt;T&gt;::type&gt;&gt; </td></tr>
<tr class="memitem:aac7f1b977c6d8977a608e96331cb44fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#aac7f1b977c6d8977a608e96331cb44fd">make_compact_copy</a> (const array_ref&lt; T, Shape &gt; &amp;src, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="separator:aac7f1b977c6d8977a608e96331cb44fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0ee9dc1719a4a4b7b1bbe1f6e555d9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d0ee9dc1719a4a4b7b1bbe1f6e555d9"></a>
template&lt;class T , class Shape , class AllocSrc , class AllocDst  = AllocSrc&gt; </td></tr>
<tr class="memitem:a0d0ee9dc1719a4a4b7b1bbe1f6e555d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_compact_copy</b> (const array&lt; T, Shape, AllocSrc &gt; &amp;src, const AllocDst &amp;alloc=AllocDst())</td></tr>
<tr class="separator:a0d0ee9dc1719a4a4b7b1bbe1f6e555d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94eb16dc22298d492152075dc8b3825"><td class="memTemplParams" colspan="2">template&lt;class TSrc , class TDst , class ShapeSrc , class ShapeDst , class  = internal::enable_if_shapes_copy_compatible&lt;ShapeDst, ShapeSrc&gt;&gt; </td></tr>
<tr class="memitem:aa94eb16dc22298d492152075dc8b3825"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#aa94eb16dc22298d492152075dc8b3825">move</a> (const array_ref&lt; TSrc, ShapeSrc &gt; &amp;src, const array_ref&lt; TDst, ShapeDst &gt; &amp;dst)</td></tr>
<tr class="separator:aa94eb16dc22298d492152075dc8b3825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad134f069defe71518659fc8d14bdc6a9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad134f069defe71518659fc8d14bdc6a9"></a>
template&lt;class TSrc , class TDst , class ShapeSrc , class ShapeDst , class AllocDst , class  = internal::enable_if_shapes_copy_compatible&lt;ShapeDst, ShapeSrc&gt;&gt; </td></tr>
<tr class="memitem:ad134f069defe71518659fc8d14bdc6a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>move</b> (const array_ref&lt; TSrc, ShapeSrc &gt; &amp;src, array&lt; TDst, ShapeDst, AllocDst &gt; &amp;dst)</td></tr>
<tr class="separator:ad134f069defe71518659fc8d14bdc6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac0fd6e65e1223f7e6f0371b01278ba"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6ac0fd6e65e1223f7e6f0371b01278ba"></a>
template&lt;class TSrc , class TDst , class ShapeSrc , class ShapeDst , class AllocSrc , class  = internal::enable_if_shapes_copy_compatible&lt;ShapeDst, ShapeSrc&gt;&gt; </td></tr>
<tr class="memitem:a6ac0fd6e65e1223f7e6f0371b01278ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>move</b> (array&lt; TSrc, ShapeSrc, AllocSrc &gt; &amp;src, const array_ref&lt; TDst, ShapeDst &gt; &amp;dst)</td></tr>
<tr class="separator:a6ac0fd6e65e1223f7e6f0371b01278ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b488cfb2a4fc9c929e2018ffaa10ac5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b488cfb2a4fc9c929e2018ffaa10ac5"></a>
template&lt;class TSrc , class TDst , class ShapeSrc , class ShapeDst , class AllocSrc , class AllocDst , class  = internal::enable_if_shapes_copy_compatible&lt;ShapeDst, ShapeSrc&gt;&gt; </td></tr>
<tr class="memitem:a6b488cfb2a4fc9c929e2018ffaa10ac5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>move</b> (array&lt; TSrc, ShapeSrc, AllocSrc &gt; &amp;src, array&lt; TDst, ShapeDst, AllocDst &gt; &amp;dst)</td></tr>
<tr class="separator:a6b488cfb2a4fc9c929e2018ffaa10ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac43714d622a45e49d7966ad0b29d80"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3ac43714d622a45e49d7966ad0b29d80"></a>
template&lt;class T , class Shape , class Alloc &gt; </td></tr>
<tr class="memitem:a3ac43714d622a45e49d7966ad0b29d80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>move</b> (array&lt; T, Shape, Alloc &gt; &amp;&amp;src, array&lt; T, Shape, Alloc &gt; &amp;dst)</td></tr>
<tr class="separator:a3ac43714d622a45e49d7966ad0b29d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae489781dfd7c05851bcc3bb770c25cb5"><td class="memTemplParams" colspan="2">template&lt;class T , class ShapeSrc , class ShapeDst , class Alloc  = std::allocator&lt;T&gt;, class  = internal::enable_if_shapes_copy_compatible&lt;ShapeDst, ShapeSrc&gt;&gt; </td></tr>
<tr class="memitem:ae489781dfd7c05851bcc3bb770c25cb5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#ae489781dfd7c05851bcc3bb770c25cb5">make_move</a> (const array_ref&lt; T, ShapeSrc &gt; &amp;src, const ShapeDst &amp;shape, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="separator:ae489781dfd7c05851bcc3bb770c25cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d19ecfb6655f522518644dcd3075897"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9d19ecfb6655f522518644dcd3075897"></a>
template&lt;class T , class ShapeSrc , class ShapeDst , class AllocSrc , class AllocDst  = AllocSrc, class  = internal::enable_if_shapes_copy_compatible&lt;ShapeDst, ShapeSrc&gt;&gt; </td></tr>
<tr class="memitem:a9d19ecfb6655f522518644dcd3075897"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_move</b> (array&lt; T, ShapeSrc, AllocSrc &gt; &amp;src, const ShapeDst &amp;shape, const AllocDst &amp;alloc=AllocDst())</td></tr>
<tr class="separator:a9d19ecfb6655f522518644dcd3075897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a00e76c5499a9192aeb696e9463c90"><td class="memTemplParams" colspan="2"><a class="anchor" id="a87a00e76c5499a9192aeb696e9463c90"></a>
template&lt;class T , class Shape , class Alloc &gt; </td></tr>
<tr class="memitem:a87a00e76c5499a9192aeb696e9463c90"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_move</b> (array&lt; T, Shape, Alloc &gt; &amp;&amp;src, const Shape &amp;shape, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="separator:a87a00e76c5499a9192aeb696e9463c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f444a4f82c3bdb70ba8aac5cdebe641"><td class="memTemplParams" colspan="2">template&lt;class T , class Shape , class Alloc  = std::allocator&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a4f444a4f82c3bdb70ba8aac5cdebe641"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a4f444a4f82c3bdb70ba8aac5cdebe641">make_compact_move</a> (const array_ref&lt; T, Shape &gt; &amp;src, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="separator:a4f444a4f82c3bdb70ba8aac5cdebe641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e63b2e9322dea99a39b3b5dc71e9263"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5e63b2e9322dea99a39b3b5dc71e9263"></a>
template&lt;class T , class Shape , class AllocSrc , class AllocDst  = AllocSrc&gt; </td></tr>
<tr class="memitem:a5e63b2e9322dea99a39b3b5dc71e9263"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_compact_move</b> (array&lt; T, Shape, AllocSrc &gt; &amp;src, const AllocDst &amp;alloc=AllocDst())</td></tr>
<tr class="separator:a5e63b2e9322dea99a39b3b5dc71e9263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8527255270dfe19122aa8b6a2333276f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8527255270dfe19122aa8b6a2333276f"></a>
template&lt;class T , class Shape , class Alloc &gt; </td></tr>
<tr class="memitem:a8527255270dfe19122aa8b6a2333276f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_compact_move</b> (array&lt; T, Shape, Alloc &gt; &amp;&amp;src, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="separator:a8527255270dfe19122aa8b6a2333276f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f24975ef5bc1a5ab2e91297dfede713"><td class="memTemplParams" colspan="2">template&lt;class T , class Shape &gt; </td></tr>
<tr class="memitem:a5f24975ef5bc1a5ab2e91297dfede713"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a5f24975ef5bc1a5ab2e91297dfede713">fill</a> (const array_ref&lt; T, Shape &gt; &amp;dst, const T &amp;value)</td></tr>
<tr class="separator:a5f24975ef5bc1a5ab2e91297dfede713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd795691548d14f8c03d7f19ff15833d"><td class="memTemplParams" colspan="2"><a class="anchor" id="afd795691548d14f8c03d7f19ff15833d"></a>
template&lt;class T , class Shape , class Alloc &gt; </td></tr>
<tr class="memitem:afd795691548d14f8c03d7f19ff15833d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fill</b> (array&lt; T, Shape, Alloc &gt; &amp;dst, const T &amp;value)</td></tr>
<tr class="separator:afd795691548d14f8c03d7f19ff15833d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097abdcd257c2c969ab07162957f2f88"><td class="memTemplParams" colspan="2">template&lt;class T , class Shape , class Generator , class  = internal::enable_if_callable&lt;Generator&gt;&gt; </td></tr>
<tr class="memitem:a097abdcd257c2c969ab07162957f2f88"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a097abdcd257c2c969ab07162957f2f88">generate</a> (const array_ref&lt; T, Shape &gt; &amp;dst, Generator &amp;&amp;g)</td></tr>
<tr class="separator:a097abdcd257c2c969ab07162957f2f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ba450e49f497adc3da69c42bab3cbd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a63ba450e49f497adc3da69c42bab3cbd"></a>
template&lt;class T , class Shape , class Alloc , class Generator , class  = internal::enable_if_callable&lt;Generator&gt;&gt; </td></tr>
<tr class="memitem:a63ba450e49f497adc3da69c42bab3cbd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>generate</b> (array&lt; T, Shape, Alloc &gt; &amp;dst, Generator &amp;&amp;g)</td></tr>
<tr class="separator:a63ba450e49f497adc3da69c42bab3cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2ce3b0013fef322816a39276cc7f1f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Shape , class Fn &gt; </td></tr>
<tr class="memitem:a0a2ce3b0013fef322816a39276cc7f1f"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a0a2ce3b0013fef322816a39276cc7f1f">transform_index</a> (const array_ref&lt; T, Shape &gt; &amp;dst, Fn &amp;&amp;fn)</td></tr>
<tr class="separator:a0a2ce3b0013fef322816a39276cc7f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788058ec2566f008730d940ad0a796ba"><td class="memTemplParams" colspan="2"><a class="anchor" id="a788058ec2566f008730d940ad0a796ba"></a>
template&lt;typename T , typename Shape , class Fn &gt; </td></tr>
<tr class="memitem:a788058ec2566f008730d940ad0a796ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform_index</b> (array&lt; T, Shape &gt; &amp;dst, Fn &amp;&amp;fn)</td></tr>
<tr class="separator:a788058ec2566f008730d940ad0a796ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fc9c2c8ebf4e41570bfee8ece7a27b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Shape , class Fn &gt; </td></tr>
<tr class="memitem:a53fc9c2c8ebf4e41570bfee8ece7a27b"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a53fc9c2c8ebf4e41570bfee8ece7a27b">transform_indices</a> (const array_ref&lt; T, Shape &gt; &amp;dst, Fn &amp;&amp;fn)</td></tr>
<tr class="separator:a53fc9c2c8ebf4e41570bfee8ece7a27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3066fc949d8d0665b69c26d331605a46"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3066fc949d8d0665b69c26d331605a46"></a>
template&lt;typename T , typename Shape , class Fn &gt; </td></tr>
<tr class="memitem:a3066fc949d8d0665b69c26d331605a46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform_indices</b> (array&lt; T, Shape &gt; &amp;dst, Fn &amp;&amp;fn)</td></tr>
<tr class="separator:a3066fc949d8d0665b69c26d331605a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000b1575954b4090010bd13bf07582f7"><td class="memTemplParams" colspan="2">template&lt;class TA , class ShapeA , class TB , class ShapeB &gt; </td></tr>
<tr class="memitem:a000b1575954b4090010bd13bf07582f7"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a000b1575954b4090010bd13bf07582f7">equal</a> (const array_ref&lt; TA, ShapeA &gt; &amp;a, const array_ref&lt; TB, ShapeB &gt; &amp;b)</td></tr>
<tr class="separator:a000b1575954b4090010bd13bf07582f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144b36c8baecfc0990f9e1823a3c1baa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a144b36c8baecfc0990f9e1823a3c1baa"></a>
template&lt;class TA , class ShapeA , class TB , class ShapeB , class AllocB &gt; </td></tr>
<tr class="memitem:a144b36c8baecfc0990f9e1823a3c1baa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal</b> (const array_ref&lt; TA, ShapeA &gt; &amp;a, const array&lt; TB, ShapeB, AllocB &gt; &amp;b)</td></tr>
<tr class="separator:a144b36c8baecfc0990f9e1823a3c1baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f04e5a589cef4260f0442123078dbd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a17f04e5a589cef4260f0442123078dbd"></a>
template&lt;class TA , class ShapeA , class AllocA , class TB , class ShapeB &gt; </td></tr>
<tr class="memitem:a17f04e5a589cef4260f0442123078dbd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal</b> (const array&lt; TA, ShapeA, AllocA &gt; &amp;a, const array_ref&lt; TB, ShapeB &gt; &amp;b)</td></tr>
<tr class="separator:a17f04e5a589cef4260f0442123078dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f299c21b7f234d28fafc46fc985180"><td class="memTemplParams" colspan="2"><a class="anchor" id="a08f299c21b7f234d28fafc46fc985180"></a>
template&lt;class TA , class ShapeA , class AllocA , class TB , class ShapeB , class AllocB &gt; </td></tr>
<tr class="memitem:a08f299c21b7f234d28fafc46fc985180"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal</b> (const array&lt; TA, ShapeA, AllocA &gt; &amp;a, const array&lt; TB, ShapeB, AllocB &gt; &amp;b)</td></tr>
<tr class="separator:a08f299c21b7f234d28fafc46fc985180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581151c44eee997515985c82272c882a"><td class="memTemplParams" colspan="2">template&lt;class NewShape , class T , class OldShape &gt; </td></tr>
<tr class="memitem:a581151c44eee997515985c82272c882a"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE array_ref&lt; T, NewShape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a581151c44eee997515985c82272c882a">convert_shape</a> (const array_ref&lt; T, OldShape &gt; &amp;a)</td></tr>
<tr class="separator:a581151c44eee997515985c82272c882a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ee1219a69aed99562ab124d638af8e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a40ee1219a69aed99562ab124d638af8e"></a>
template&lt;class NewShape , class T , class OldShape , class Allocator &gt; </td></tr>
<tr class="memitem:a40ee1219a69aed99562ab124d638af8e"><td class="memTemplItemLeft" align="right" valign="top">array_ref&lt; T, NewShape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_shape</b> (array&lt; T, OldShape, Allocator &gt; &amp;a)</td></tr>
<tr class="separator:a40ee1219a69aed99562ab124d638af8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222ed4f4d7439191b146c3e585fdc222"><td class="memTemplParams" colspan="2"><a class="anchor" id="a222ed4f4d7439191b146c3e585fdc222"></a>
template&lt;class NewShape , class T , class OldShape , class Allocator &gt; </td></tr>
<tr class="memitem:a222ed4f4d7439191b146c3e585fdc222"><td class="memTemplItemLeft" align="right" valign="top">const_array_ref&lt; T, NewShape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_shape</b> (const array&lt; T, OldShape, Allocator &gt; &amp;a)</td></tr>
<tr class="separator:a222ed4f4d7439191b146c3e585fdc222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94904069da979eb472c385bc6d98ad82"><td class="memTemplParams" colspan="2">template&lt;class U , class T , class Shape , class  = std::enable_if_t&lt;sizeof(T) == sizeof(U)&gt;&gt; </td></tr>
<tr class="memitem:a94904069da979eb472c385bc6d98ad82"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE array_ref&lt; U, Shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a94904069da979eb472c385bc6d98ad82">reinterpret</a> (const array_ref&lt; T, Shape &gt; &amp;a)</td></tr>
<tr class="separator:a94904069da979eb472c385bc6d98ad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad0fa42acddb809a003bed390d2f28d"><td class="memTemplParams" colspan="2"><a class="anchor" id="abad0fa42acddb809a003bed390d2f28d"></a>
template&lt;class U , class T , class Shape , class Alloc , class  = std::enable_if_t&lt;sizeof(T) == sizeof(U)&gt;&gt; </td></tr>
<tr class="memitem:abad0fa42acddb809a003bed390d2f28d"><td class="memTemplItemLeft" align="right" valign="top">array_ref&lt; U, Shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpret</b> (array&lt; T, Shape, Alloc &gt; &amp;a)</td></tr>
<tr class="separator:abad0fa42acddb809a003bed390d2f28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa26220080b2a313407ea6f5786beae"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8aa26220080b2a313407ea6f5786beae"></a>
template&lt;class U , class T , class Shape , class Alloc , class  = std::enable_if_t&lt;sizeof(T) == sizeof(U)&gt;&gt; </td></tr>
<tr class="memitem:a8aa26220080b2a313407ea6f5786beae"><td class="memTemplItemLeft" align="right" valign="top">const_array_ref&lt; U, Shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpret</b> (const array&lt; T, Shape, Alloc &gt; &amp;a)</td></tr>
<tr class="separator:a8aa26220080b2a313407ea6f5786beae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11efc76a7f3b6677b9110c33d91e4198"><td class="memTemplParams" colspan="2">template&lt;class U , class T , class Shape &gt; </td></tr>
<tr class="memitem:a11efc76a7f3b6677b9110c33d91e4198"><td class="memTemplItemLeft" align="right" valign="top">array_ref&lt; U, Shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#a11efc76a7f3b6677b9110c33d91e4198">reinterpret_const</a> (const const_array_ref&lt; T, Shape &gt; &amp;a)</td></tr>
<tr class="separator:a11efc76a7f3b6677b9110c33d91e4198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5286df6ef0b7546aa6eed5642ec3e9"><td class="memTemplParams" colspan="2">template&lt;class NewShape , class T , class OldShape &gt; </td></tr>
<tr class="memitem:afe5286df6ef0b7546aa6eed5642ec3e9"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE array_ref&lt; T, NewShape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#afe5286df6ef0b7546aa6eed5642ec3e9">reinterpret_shape</a> (const array_ref&lt; T, OldShape &gt; &amp;a, const NewShape &amp;new_shape, index_t offset=0)</td></tr>
<tr class="separator:afe5286df6ef0b7546aa6eed5642ec3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccd61ac5d8beb4c48a0c7a955a70253"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9ccd61ac5d8beb4c48a0c7a955a70253"></a>
template&lt;class NewShape , class T , class OldShape , class Allocator &gt; </td></tr>
<tr class="memitem:a9ccd61ac5d8beb4c48a0c7a955a70253"><td class="memTemplItemLeft" align="right" valign="top">array_ref&lt; T, NewShape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpret_shape</b> (array&lt; T, OldShape, Allocator &gt; &amp;a, const NewShape &amp;new_shape, index_t offset=0)</td></tr>
<tr class="separator:a9ccd61ac5d8beb4c48a0c7a955a70253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c95d2f380ae665c82b8a610bb2ab0b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8c95d2f380ae665c82b8a610bb2ab0b8"></a>
template&lt;class NewShape , class T , class OldShape , class Allocator &gt; </td></tr>
<tr class="memitem:a8c95d2f380ae665c82b8a610bb2ab0b8"><td class="memTemplItemLeft" align="right" valign="top">const_array_ref&lt; T, NewShape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpret_shape</b> (const array&lt; T, OldShape, Allocator &gt; &amp;a, const NewShape &amp;new_shape, index_t offset=0)</td></tr>
<tr class="separator:a8c95d2f380ae665c82b8a610bb2ab0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab424a858ee8c8c675cd05db0e969cbb7"><td class="memTemplParams" colspan="2">template&lt;typename NewShape , typename T , typename OldShape , typename Alloc &gt; </td></tr>
<tr class="memitem:ab424a858ee8c8c675cd05db0e969cbb7"><td class="memTemplItemLeft" align="right" valign="top">array&lt; T, NewShape, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#ab424a858ee8c8c675cd05db0e969cbb7">move_reinterpret_shape</a> (array&lt; T, OldShape, Alloc &gt; &amp;&amp;from, const NewShape &amp;new_shape, index_t offset=0)</td></tr>
<tr class="separator:ab424a858ee8c8c675cd05db0e969cbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507f1a8de827031f32091a2f8a70eff2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a507f1a8de827031f32091a2f8a70eff2"></a>
template&lt;typename NewShape , typename T , typename OldShape , typename Alloc &gt; </td></tr>
<tr class="memitem:a507f1a8de827031f32091a2f8a70eff2"><td class="memTemplItemLeft" align="right" valign="top">array&lt; T, NewShape, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>move_reinterpret_shape</b> (array&lt; T, OldShape, Alloc &gt; &amp;&amp;from, index_t offset=0)</td></tr>
<tr class="separator:a507f1a8de827031f32091a2f8a70eff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae104ce770dff1fe22fd6d68591be9647"><td class="memTemplParams" colspan="2">template&lt;size_t... DimIndices, class T , class OldShape , class  = internal::enable_if_permutation&lt;OldShape::rank(), DimIndices...&gt;&gt; </td></tr>
<tr class="memitem:ae104ce770dff1fe22fd6d68591be9647"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="array_8h.html#ae104ce770dff1fe22fd6d68591be9647">transpose</a> (const array_ref&lt; T, OldShape &gt; &amp;a)</td></tr>
<tr class="separator:ae104ce770dff1fe22fd6d68591be9647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7396c35eff8265aec9f135823d44a9f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad7396c35eff8265aec9f135823d44a9f"></a>
template&lt;size_t... DimIndices, class T , class OldShape , class Allocator , class  = internal::enable_if_permutation&lt;OldShape::rank(), DimIndices...&gt;&gt; </td></tr>
<tr class="memitem:ad7396c35eff8265aec9f135823d44a9f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (array&lt; T, OldShape, Allocator &gt; &amp;a)</td></tr>
<tr class="separator:ad7396c35eff8265aec9f135823d44a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3980bea7e462fb428078ddce82ba4812"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3980bea7e462fb428078ddce82ba4812"></a>
template&lt;size_t... DimIndices, class T , class OldShape , class Allocator , class  = internal::enable_if_permutation&lt;OldShape::rank(), DimIndices...&gt;&gt; </td></tr>
<tr class="memitem:a3980bea7e462fb428078ddce82ba4812"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (const array&lt; T, OldShape, Allocator &gt; &amp;a)</td></tr>
<tr class="separator:a3980bea7e462fb428078ddce82ba4812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2626b1fc9bcffca5eef1ff4b2d914d5f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2626b1fc9bcffca5eef1ff4b2d914d5f"></a>
template&lt;size_t... DimIndices, class T , class OldShape &gt; </td></tr>
<tr class="memitem:a2626b1fc9bcffca5eef1ff4b2d914d5f"><td class="memTemplItemLeft" align="right" valign="top">NDARRAY_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reorder</b> (const array_ref&lt; T, OldShape &gt; &amp;a)</td></tr>
<tr class="separator:a2626b1fc9bcffca5eef1ff4b2d914d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad376484305a48b84569df6116bc82988"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad376484305a48b84569df6116bc82988"></a>
template&lt;size_t... DimIndices, class T , class OldShape , class Allocator &gt; </td></tr>
<tr class="memitem:ad376484305a48b84569df6116bc82988"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reorder</b> (array&lt; T, OldShape, Allocator &gt; &amp;a)</td></tr>
<tr class="separator:ad376484305a48b84569df6116bc82988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fea722014c4ad746cc9e608981233c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a75fea722014c4ad746cc9e608981233c"></a>
template&lt;size_t... DimIndices, class T , class OldShape , class Allocator &gt; </td></tr>
<tr class="memitem:a75fea722014c4ad746cc9e608981233c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reorder</b> (const array&lt; T, OldShape, Allocator &gt; &amp;a)</td></tr>
<tr class="separator:a75fea722014c4ad746cc9e608981233c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:adab240e3956fad6af13ebafd594e007b"><td class="memItemLeft" align="right" valign="top">constexpr index_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#adab240e3956fad6af13ebafd594e007b">dynamic</a> = -9</td></tr>
<tr class="separator:adab240e3956fad6af13ebafd594e007b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cbcb2625d5f9587be3b3961bb894fe"><td class="memItemLeft" align="right" valign="top">constexpr index_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a09cbcb2625d5f9587be3b3961bb894fe">unresolved</a> = std::numeric_limits&lt;index_t&gt;::min()</td></tr>
<tr class="separator:a09cbcb2625d5f9587be3b3961bb894fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b8df81276b556535053bc15e7da68c"><td class="memItemLeft" align="right" valign="top">const interval&lt; 0,-1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#ac1b8df81276b556535053bc15e7da68c">all</a></td></tr>
<tr class="separator:ac1b8df81276b556535053bc15e7da68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a49d7e4a642f999d1e6e221a98cb44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98a49d7e4a642f999d1e6e221a98cb44"></a>
const interval&lt; 0,-1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_</b></td></tr>
<tr class="separator:a98a49d7e4a642f999d1e6e221a98cb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main header for array library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="file_a26493ae85adc5b160363a05a6cd4f11e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using index_t =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When <code>NDARRAY_INT_INDICES</code> is defined, array indices are <code>int</code> values, otherwise they are <code>std::ptrdiff_t</code>. std::ptrdiff_t is helpful for the compiler to optimize address arithmetic, because it has the same size as a pointer. </p>

</div>
</div>
<a class="anchor" id="file_a211cabf0fcc1a09e896e0af76704dd6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using fixed_interval =  interval&lt;dynamic, Extent&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias of <code>interval</code> with a fixed extent and dynamic min. This is useful as the inner part of a <code>split</code> with a fixed extent. </p>

</div>
</div>
<a class="anchor" id="file_adb0209166945d62a1629fc11e434ac98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using fixed_dim =  dim&lt;dynamic, Extent, Stride&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias of <code>dim</code> where the min is not specified at compile time. </p>

</div>
</div>
<a class="anchor" id="file_a00c87b9adb5a4f4ad386e78145eabc2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using dense_dim =  dim&lt;Min, Extent, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias of <code>dim</code> where the compile-time stride parameter is known to be one. </p>

</div>
</div>
<a class="anchor" id="file_a9025cb1177525c1b8587b589ca647e4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using strided_dim =  dim&lt;dynamic, dynamic, Stride&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias of <code>dim</code> where only the stride parameter is specified at compile time. </p>

</div>
</div>
<a class="anchor" id="file_a1c13f3faa99c074549d5f2265cc7ba1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using broadcast_dim =  dim&lt;Min, Extent, 0&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias of <code>dim</code> where the compile-time stride parameter is known to be zero. </p>

</div>
</div>
<a class="anchor" id="file_ad7866b82526d5276e559a3bc02e09686"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using index_of_rank =  internal::tuple_of_n&lt;index_t, Rank&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of an index for an array of rank <code>Rank</code>. This will be <code>std::tuple&lt;...&gt;</code> with <code>Rank</code> <code>index_t</code> values.</p>
<p>For example, <code>index_of_rank&lt;3&gt;</code> is <code>std::tuple&lt;index_t, index_t, index_t&gt;</code>. </p>

</div>
</div>
<a class="anchor" id="file_a61e0c3b2fc19efea03b595a9fbe2ba23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using shape_of_rank =  decltype(make_shape_from_tuple(internal::tuple_of_n&lt;dim&lt;&gt;, Rank&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An arbitrary <code>shape</code> with the specified rank <code>Rank</code>. This shape is compatible with any other shape of the same rank. </p>

</div>
</div>
<a class="anchor" id="file_aa200a0a9e702ec0241adb18f351acbe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using dense_shape =  decltype(internal::make_default_dense_shape&lt;Rank&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>shape</code> where the innermost dimension is a <code>dense_dim</code>, and all other dimensions are arbitrary. </p>

</div>
</div>
<a class="anchor" id="file_ac7b935efb37c2765a3aae7b2ecaeec26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using fixed_dense_shape =  decltype(make_shape_from_tuple(internal::make_compact_dims&lt;1&gt;(dim&lt;0, Extents&gt;()...)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>shape</code> where all extents (and automatically computed compact strides) are constant. </p>

</div>
</div>
<a class="anchor" id="file_a4edeffa5f4878abb67a08b3eccdc9d2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using array_ref_of_rank =  array_ref&lt;T, shape_of_rank&lt;Rank&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classnda_1_1array__ref.html">array_ref</a> with an arbitrary shape of rank <code>Rank</code>. </p>

</div>
</div>
<a class="anchor" id="file_a3bbaedd9bb2f66c68d0dbc60fefafde1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using dense_array_ref =  array_ref&lt;T, dense_shape&lt;Rank&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classnda_1_1array__ref.html">array_ref</a> with a shape <code>dense_shape&lt;Rank&gt;</code>. </p>

</div>
</div>
<a class="anchor" id="file_aec3848811e2aae330fb669a23f30cd2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using array_of_rank =  array&lt;T, shape_of_rank&lt;Rank&gt;, Alloc&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An array type with an arbitrary shape of rank <code>Rank</code>. </p>

</div>
</div>
<a class="anchor" id="file_a6fd5dd48fcb68ce48daff5d746cb297c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using dense_array =  array&lt;T, dense_shape&lt;Rank&gt;, Alloc&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An array type with shape <code>dense_shape&lt;Rank&gt;</code>. </p>

</div>
</div>
<a class="anchor" id="file_a8aaf81b16b0c4bc1c603dbb31f640b23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using uninitialized_std_allocator =  uninitialized_allocator&lt;std::allocator&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocator equivalent to <code>std::allocator&lt;T&gt;</code> that does not default construct values. </p>

</div>
</div>
<a class="anchor" id="file_a574fafc712a9b945bad45a98e95a5bcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using uninitialized_auto_allocator =  uninitialized_allocator&lt;auto_allocator&lt;T, N, Alignment&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocator equivalent to <code><a class="el" href="classnda_1_1auto__allocator.html">auto_allocator</a>&lt;T, N, Alignment&gt;</code> that does not default construct values. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="file_aaaa66a68a53c7780294f443c9da40fb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_INLINE NDARRAY_HOST_DEVICE interval nda::range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="array_8h.html#a26493ae85adc5b160363a05a6cd4f11e">index_t</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a26493ae85adc5b160363a05a6cd4f11e">index_t</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make an interval from a half-open range <code>[begin, end)</code>. </p>

</div>
</div>
<a class="anchor" id="file_a41e4d24524ff36ed841fa23295347628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE fixed_interval&lt;Extent&gt; nda::range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="array_8h.html#a26493ae85adc5b160363a05a6cd4f11e">index_t</a>&#160;</td>
          <td class="paramname"><em>begin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make an interval from a half-open range <code>[begin, begin + Extent)</code>. </p>

</div>
</div>
<a class="anchor" id="file_a074fffb7cad44b70b9a5dc0793560dfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE index_iterator nda::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1interval.html">interval</a>&lt; Min, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads of <code>std::begin</code> and <code>std::end</code> for an interval. </p>

</div>
</div>
<a class="anchor" id="file_a191ec3144f7249e6f2679ce4648e3c67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_INLINE NDARRAY_HOST_DEVICE index_t nda::clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="array_8h.html#a26493ae85adc5b160363a05a6cd4f11e">index_t</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a26493ae85adc5b160363a05a6cd4f11e">index_t</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a26493ae85adc5b160363a05a6cd4f11e">index_t</a>&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clamp <code>x</code> to the interval [min, max]. </p>

</div>
</div>
<a class="anchor" id="file_a14484b48d68ae36f12f40248f78f2b43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE index_t nda::clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="array_8h.html#a26493ae85adc5b160363a05a6cd4f11e">index_t</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clamp <code>x</code> to the range described by an object <code>r</code> with a <code>min()</code> and <code>max()</code> method. </p>

</div>
</div>
<a class="anchor" id="file_a3d05a3211e2c3a5e86eb63559ae4a7ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE internal::split_result&lt;InnerExtent&gt; nda::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1interval.html">interval</a>&lt; Min, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split an interval <code>v</code> into an iteratable range of intervals by a compile-time constant <code>InnerExtent</code>. If <code>InnerExtent</code> does not divide <code>v.extent()</code>, the last interval will be shifted to overlap with the second-to-last iteration, to preserve the compile-time constant extent, which implies <code>v.extent()</code> must be larger <code>InnerExtent</code>.</p>
<p>Examples:</p><ul>
<li><code>split&lt;4&gt;(interval&lt;&gt;(0, 8))</code> produces the intervals <code>[0, 4)</code>, <code>[4, 8)</code>.</li>
<li><code>split&lt;5&gt;(interval&lt;&gt;(0, 12))</code> produces the intervals <code>[0, 5)</code>, <code>[5, 10)</code>, <code>[7, 12)</code>. Note the last two intervals overlap. </li>
</ul>

</div>
</div>
<a class="anchor" id="file_aad010fde354a851daf6ad43533c758ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE internal::split_result nda::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1interval.html">interval</a>&lt; Min, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a26493ae85adc5b160363a05a6cd4f11e">index_t</a>&#160;</td>
          <td class="paramname"><em>inner_extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split an interval <code>v</code> into an iterable range of intervals by <code>inner_extent</code>. If <code>inner_extent</code> does not divide <code>v.extent()</code>, the last iteration will be clamped to the outer interval.</p>
<p>Examples:</p><ul>
<li><code>split(interval&lt;&gt;(0, 12), 5)</code> produces the intervals <code>[0, 5)</code>, <code>[5, 10)</code>, <code>[10, 12)</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="file_acc77f5082e94f21c95849a1eefd016c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE auto nda::make_shape </td>
          <td>(</td>
          <td class="paramtype">Dims...&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to make a shape from a variadic list of <code>dims...</code>. </p>

</div>
</div>
<a class="anchor" id="file_af2e4d426486c09a1a9520aa95975be5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE auto nda::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1shape.html">shape</a>&lt; Dims... &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new shape using a list of <code>DimIndices...</code> to use as the dimensions of the shape. The new shape's i'th dimension will be the j'th dimension of <code>shape</code> where j is the i'th value of <code>DimIndices...</code>. If i is not in <code>DimIndices...</code>, then i and j are equal.</p>
<p><code>DimIndices...</code> must be a permutation of <code>[0, N)</code> where N is the number of indices provided.</p>
<p>Examples:</p><ul>
<li><code>transpose&lt;2, 0, 1&gt;(s) == make_shape(s.dim&lt;2&gt;(), s.dim&lt;0&gt;(), s.dim&lt;1&gt;())</code></li>
<li><code>transpose&lt;1, 0&gt;(s) == make_shape(s.dim&lt;1&gt;(), s.dim&lt;0&gt;(), ...)</code> where ... is all dimensions after dimension 1. </li>
</ul>

</div>
</div>
<a class="anchor" id="file_ac330ca487f4b29eb13861850de98a38f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE auto nda::reorder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1shape.html">shape</a>&lt; Dims... &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new shape using a list of <code>DimIndices...</code> to use as the dimensions of the shape. The new shape's i'th dimension will be the j'th dimension of <code>shape</code> where j is the i'th value of <code>DimIndices...</code>.</p>
<p>Examples:</p><ul>
<li><code>reorder&lt;1, 2&gt;(s) == make_shape(s.dim&lt;1&gt;(), s.dim&lt;2&gt;())</code> </li>
</ul>

</div>
</div>
<a class="anchor" id="file_ab5aeff46be2236fb32a203dfd2c0f6fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE auto nda::make_compact </td>
          <td>(</td>
          <td class="paramtype">const Shape &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to make both the compile-time and run-time strides of <code>s</code> compact such that there is no padding between dimensions. Only dynamic strides are potentially replaced with static strides, existing compile-time strides are not modified. Run-time strides are then populated using the <code><a class="el" href="classnda_1_1shape.html#a8472f3f7cc197a1fc281879d13e3e767">shape::resolve</a></code> algorithm.</p>
<p>For a shape without any existing constant strides, this will return an instance of <code>dense_shape&lt;Shape::rank()&gt;</code>.</p>
<p>The resulting shape may not have <code>Shape::is_compact</code> return <code>true</code> if the shape has existing non-compact compile-time constant strides. </p>

</div>
</div>
<a class="anchor" id="file_ac68a87c9486d77bb1c2c8bc8f3587290"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE bool nda::is_compatible </td>
          <td>(</td>
          <td class="paramtype">const ShapeSrc &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if a shape <code>src</code> can be assigned to a shape of type <code>ShapeDst</code> without error. </p>

</div>
</div>
<a class="anchor" id="file_aa632dc4e183e8b352b3b5fc49740f5e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE ShapeDst nda::convert_shape </td>
          <td>(</td>
          <td class="paramtype">const ShapeSrc &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a shape <code>src</code> to shape type <code>ShapeDst</code>. This explicit conversion allows converting a low rank shape to a higher ranked shape where new dimensions have min 0 and extent 1, and it allows converting a high rank shape to a lower rank shape if the dimensions being sliced are trivial (they have extent one). </p>

</div>
</div>
<a class="anchor" id="file_aef30cae2d67c4103d15cfbcfff0f349a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE bool nda::is_explicitly_compatible </td>
          <td>(</td>
          <td class="paramtype">const ShapeSrc &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if a shape <code>src</code> can be explicitly converted to a shape of type <code>ShapeDst</code> using <code>convert_shape</code> without error. </p>

</div>
</div>
<a class="anchor" id="file_acf31907f3bad61a417e225e5e135b7df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_UNIQUE NDARRAY_HOST_DEVICE void nda::for_each_index_in_order </td>
          <td>(</td>
          <td class="paramtype">const Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over all indices in the shape, calling a function <code>fn</code> for each set of indices. The indices are in the same order as the dims in the shape. The first dim is the 'inner' loop of the iteration, and the last dim is the 'outer' loop.</p>
<p>These functions are typically used to implement <code><a class="el" href="classnda_1_1shape__traits.html">shape_traits</a>&lt;&gt;</code> and <code><a class="el" href="classnda_1_1copy__shape__traits.html">copy_shape_traits</a>&lt;&gt;</code> objects. Use <code>for_each_index</code>, <code><a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt;&gt;::for_each_value</code>, or <code>array&lt;&gt;::for_each_value</code> instead. </p>

</div>
</div>
<a class="anchor" id="file_a926d23314527bd0010642a211ed7b146"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_UNIQUE NDARRAY_HOST_DEVICE void nda::for_each_value_in_order </td>
          <td>(</td>
          <td class="paramtype">const Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ShapeA &amp;&#160;</td>
          <td class="paramname"><em>shape_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PtrA&#160;</td>
          <td class="paramname"><em>base_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ShapeB &amp;&#160;</td>
          <td class="paramname"><em>shape_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PtrB&#160;</td>
          <td class="paramname"><em>base_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <code>for_each_value_in_order</code>, but iterates over two arrays simultaneously. <code>shape</code> defines the loop nest, while <code>shape_a</code> and <code>shape_b</code> define the memory layout of <code>base_a</code> and <code>base_b</code>.</p>
<p>The min and extent of arrays a and b must be contained in <code>shape</code>, otherwise values may be read out of bounds. No bounds checking is done in this function; only <code>shape_a</code> and <code>shape_b</code>'s strides are considered. </p>

</div>
</div>
<a class="anchor" id="file_aeedf4c4fe3a73f56a9f72ea34a2b6dad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_UNIQUE NDARRAY_HOST_DEVICE void for_each_index </td>
          <td>(</td>
          <td class="paramtype">const Shape &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over all indices in the shape <code>s</code>, calling a function <code>fn</code> for each set of indices. <code>for_all_indices</code> calls <code>fn</code> with a list of arguments corresponding to each dim. <code>for_each_index</code> calls <code>fn</code> with an index tuple describing the indices.</p>
<p>If the <code>LoopOrder...</code> permutation is empty, the order of the loops is defined by <code><a class="el" href="classnda_1_1shape__traits.html">shape_traits</a>&lt;Shape&gt;</code>, and the callable <code>fn</code> must accept a <code>Shape::index_type</code> in the case of <code>for_each_index</code>, or <code>Shape::rank()</code> <code>index_t</code> objects in the case of <code>for_all_indices</code>.</p>
<p>If the <code>LoopOrder...</code> permutation is not empty, the order of the loops is defined by this ordering. The first index of <code>LoopOrder...</code> is the innermost loop of the loop nest. The callable <code>fn</code> must accept an <code>index_of_rank&lt;sizeof...(LoopOprder)&gt;</code> in the case of <code>for_each_index&lt;&gt;</code>, or <code>sizeof...(LoopOrder)</code> <code>index_t</code> objects in the case of <code>for_all_indices&lt;&gt;</code>. </p>

</div>
</div>
<a class="anchor" id="file_a1ce93c483b477a4339650673058b60ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE array_ref&lt;T, Shape&gt; nda::make_array_ref </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a new <code><a class="el" href="classnda_1_1array__ref.html">array_ref</a></code> with shape <code>shape</code> and base pointer <code>base</code>. </p>

</div>
</div>
<a class="anchor" id="file_a7b4a05d3f1a2fe00507e35bc10c516dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto nda::make_array </td>
          <td>(</td>
          <td class="paramtype">const Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a new array with shape <code>shape</code>, allocated using the allocator <code>alloc</code>. </p>

</div>
</div>
<a class="anchor" id="file_a842dbbf31ce75db1a54a7b498df53995"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nda::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnda_1_1array.html">array</a>&lt; T, Shape, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnda_1_1array.html">array</a>&lt; T, Shape, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the contents of two arrays. </p>

</div>
</div>
<a class="anchor" id="file_a01b188d9c649d32dde879e9635553236"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nda::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; TSrc, ShapeSrc &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; TDst, ShapeDst &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the contents of the <code>src</code> array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a> to the <code>dst</code> array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a>. The elements in the shape of <code>dst</code> will be copied, and must be in bounds of <code>src</code>. </p>

</div>
</div>
<a class="anchor" id="file_a7c58e26230741655aa32a915844758b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto nda::make_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; T, ShapeSrc &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a copy of the <code>src</code> array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a> with a new allocator <code>alloc</code>. </p>

</div>
</div>
<a class="anchor" id="file_a9c7d8cbb1a7ea679f9b0bba99d3d3150"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto nda::make_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; T, ShapeSrc &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ShapeDst &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a copy of the <code>src</code> array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a> with a new shape <code>shape</code>. </p>

</div>
</div>
<a class="anchor" id="file_aac7f1b977c6d8977a608e96331cb44fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto nda::make_compact_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; T, Shape &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a copy of the <code>src</code> array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a> with a compact version of <code>src</code>'s shape. </p>

</div>
</div>
<a class="anchor" id="file_aa94eb16dc22298d492152075dc8b3825"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nda::move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; TSrc, ShapeSrc &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; TDst, ShapeDst &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move the contents from the <code>src</code> array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a> to the <code>dst</code> array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a>. The interval of the shape of <code>dst</code> will be moved, and must be in bounds of <code>src</code>. </p>

</div>
</div>
<a class="anchor" id="file_ae489781dfd7c05851bcc3bb770c25cb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto nda::make_move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; T, ShapeSrc &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ShapeDst &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a copy of the <code>src</code> array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a> with a new shape <code>shape</code>. The elements of <code>src</code> are moved to the result. </p>

</div>
</div>
<a class="anchor" id="file_a4f444a4f82c3bdb70ba8aac5cdebe641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto nda::make_compact_move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; T, Shape &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a copy of the <code>src</code> array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a> with a compact version of <code>src</code>'s shape. The elements of <code>src</code> are moved to the result. </p>

</div>
</div>
<a class="anchor" id="file_a5f24975ef5bc1a5ab2e91297dfede713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE void nda::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; T, Shape &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill the <code>dst</code> array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a> by copy-assigning <code>value</code>. </p>

</div>
</div>
<a class="anchor" id="file_a097abdcd257c2c969ab07162957f2f88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE void nda::generate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; T, Shape &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Generator &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill the <code>dst</code> array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a> with the result of calling a generator function <code>g</code>. The order in which <code>g</code> is called is the same as <code><a class="el" href="classnda_1_1shape__traits.html">shape_traits</a>&lt;Shape&gt;::for_each_value</code>. </p>

</div>
</div>
<a class="anchor" id="file_a0a2ce3b0013fef322816a39276cc7f1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE void nda::transform_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; T, Shape &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill the <code>dst</code> array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a> with the result of calling a "pattern
function" <code>fn</code>, which takes a single <a class="el" href="classnda_1_1shape.html#a97955e667dea657b46e7a1c6dc8662b0">shape::index_type</a> argument. The order in which <code>fn</code> is called is the same as <code><a class="el" href="classnda_1_1shape__traits.html">shape_traits</a>&lt;Shape&gt;::for_each_index</code>. </p>

</div>
</div>
<a class="anchor" id="file_a53fc9c2c8ebf4e41570bfee8ece7a27b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE void nda::transform_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; T, Shape &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill the <code>dst</code> array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a> with the result of calling a "pattern
function" <code>fn</code>, which takes as as many index_t arguments as there are dimensions in <code>dst</code>. The order in which <code>fn</code> is called is the same as <code><a class="el" href="classnda_1_1shape__traits.html">shape_traits</a>&lt;Shape&gt;::for_each_index</code>. </p>

</div>
</div>
<a class="anchor" id="file_a000b1575954b4090010bd13bf07582f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE bool nda::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; TA, ShapeA &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; TB, ShapeB &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if two array or array_refs have equal contents. </p>

</div>
</div>
<a class="anchor" id="file_a581151c44eee997515985c82272c882a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE array_ref&lt;T, NewShape&gt; nda::convert_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; T, OldShape &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert the shape of the array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a> <code>a</code> to a new type of shape <code>NewShape</code>. The new shape is copy constructed from <code>a.shape()</code>. </p>

</div>
</div>
<a class="anchor" id="file_a94904069da979eb472c385bc6d98ad82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE array_ref&lt;U, Shape&gt; nda::reinterpret </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; T, Shape &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinterpret the array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a> <code>a</code> of type <code>T</code> to have a different type <code>U</code>. <code>sizeof(T)</code> must be equal to <code>sizeof(U)</code>. </p>

</div>
</div>
<a class="anchor" id="file_a11efc76a7f3b6677b9110c33d91e4198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array_ref&lt;U, Shape&gt; nda::reinterpret_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">const_array_ref</a>&lt; T, Shape &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinterpret the const_array_ref <code>a</code> of type <code>T</code> (aka array_ref&lt;const T&gt;) to have a different type <code>U</code> using <code>const_cast</code>. </p>

</div>
</div>
<a class="anchor" id="file_afe5286df6ef0b7546aa6eed5642ec3e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE array_ref&lt;T, NewShape&gt; nda::reinterpret_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; T, OldShape &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NewShape &amp;&#160;</td>
          <td class="paramname"><em>new_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a26493ae85adc5b160363a05a6cd4f11e">index_t</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinterpret the shape of the array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a> <code>a</code> to be a new shape <code>new_shape</code>, with a base pointer offset <code>offset</code>. </p>

</div>
</div>
<a class="anchor" id="file_ab424a858ee8c8c675cd05db0e969cbb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;T, NewShape, Alloc&gt; nda::move_reinterpret_shape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnda_1_1array.html">array</a>&lt; T, OldShape, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NewShape &amp;&#160;</td>
          <td class="paramname"><em>new_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a26493ae85adc5b160363a05a6cd4f11e">index_t</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move an array <code>from</code> to a new array, reinterpreting the shape of the array to <code>new_shape</code>, with a base pointer offset <code>offset</code>. This is only available for trivial <code>T</code>, because it does not guarantee that newly accessible elements are constructed, or newly inaccessible elements are destructed. </p>

</div>
</div>
<a class="anchor" id="file_ae104ce770dff1fe22fd6d68591be9647"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDARRAY_HOST_DEVICE auto nda::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnda_1_1array__ref.html">array_ref</a>&lt; T, OldShape &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinterpret the shape of the array or <a class="el" href="classnda_1_1array__ref.html">array_ref</a> <code>a</code> to be transposed or reordered using <code>transpose&lt;DimIndices...&gt;(a.shape())</code> or <code>reorder&lt;DimIndices...&gt;(a.shape())</code>. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="file_adab240e3956fad6af13ebafd594e007b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr index_t dynamic = -9</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This value indicates a compile-time constant parameter is an unknown value, and to use the corresponding runtime value instead. If a compile-time constant value is not <code>dynamic</code>, it is said to be <code>static</code>. A runtime value is said to be 'compatible with' a compile-time constant value if the values are equal, or the compile-time constant value is dynamic. </p>

</div>
</div>
<a class="anchor" id="file_a09cbcb2625d5f9587be3b3961bb894fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr index_t unresolved = std::numeric_limits&lt;index_t&gt;::min()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This value indicates a runtime parameter is an unknown value, and may be replaced by a default value computed by the library. </p>

</div>
</div>
<a class="anchor" id="file_ac1b8df81276b556535053bc15e7da68c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const interval&lt;0, -1&gt; all</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Placeholder object representing an interval that indicates keep the whole dimension when used in an indexing expression. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
